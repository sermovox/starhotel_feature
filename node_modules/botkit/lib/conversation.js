"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dialogWrapper_1 = require("./dialogWrapper");
const botbuilder_1 = require("botbuilder");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const mustache = require("mustache");
const debug = require('debug')('botkit:conversation');
/**
 * An extension on the [BotBuilder Dialog Class](https://docs.microsoft.com/en-us/javascript/api/botbuilder-dialogs/dialog?view=botbuilder-ts-latest) that provides a Botkit-friendly interface for
 * defining and interacting with multi-message dialogs. Dialogs can be constructed using `say()`, `ask()` and other helper methods.
 *
 * ```javascript
 * // define the structure of your dialog...
 * const convo = new BotkitConversation('foo', controller);
 * convo.say('Hello!');
 * convo.ask('What is your name?', async(answer, convo, bot) => {
 *      await bot.say('Your name is ' + answer);
 * });
 * controller.dialogSet.add(convo);
 *
 * // later on, trigger this dialog by its id
 * controller.on('event', async(bot, message) => {
 *  await bot.beginDialog('foo');
 * })
 * ```
 */
class BotkitConversation extends botbuilder_dialogs_1.Dialog {
    /**
     * Create a new BotkitConversation object
     * @param dialogId A unique identifier for this dialog, used to later trigger this dialog
     * @param controller A pointer to the main Botkit controller
     */
    constructor(dialogId, controller) {
        super(dialogId);
        console.log(' botkitconvo requested id ',dialogId);

        this.mustacheF=null;// store singleton for mustache function ( do they persist ? cant be set in status as itt wont store functions )

        this._beforeHooks = {};
        this._afterHooks = [];
        this._changeHooks = {};
        this.script = {};
        this._controller = controller;
        // Make sure there is a prompt we can use.
        // TODO: maybe this ends up being managed by Botkit
        this._prompt = this.id + '_default_prompt';
        this._controller.dialogSet.add(new botbuilder_dialogs_1.TextPrompt(this._prompt));
        return this;
    }
    /**
     * Add a non-interactive message to the default thread.
     * Messages added with `say()` and `addMessage()` will _not_ wait for a response, will be sent one after another without a pause.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     *
     * ```javascript
     * let conversation = new BotkitConversation('welcome', controller);
     * conversation.say('Hello! Welcome to my app.');
     * conversation.say('Let us get started...');
     * ```
     *
     * @param message Message template to be sent
     */
    say(message) {
        this.addMessage(message, 'default');
        return this;
    }
    /**
     * An an action to the conversation timeline. This can be used to go to switch threads or end the dialog.
     *
     * When provided the name of another thread in the conversation, this will cause the bot to go immediately
     * to that thread.
     *
     * Otherwise, use one of the following keywords:
     * * `stop`
     * * `repeat`
     * * `complete`
     * * `timeout`
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     *
     * ```javascript
     *
     * // go to a thread called "next_thread"
     * convo.addAction('next_thread');
     *
     * // end the conversation and mark as successful
     * convo.addAction('complete');
     * ```
     * @param action An action or thread name
     * @param thread_name The name of the thread to which this action is added.  Defaults to `default`
     */
    addAction(action, thread_name = 'default') {
        this.addMessage({ action: action }, thread_name);
        return this;
    }
    /**
     * Cause the dialog to call a child dialog, wait for it to complete,
     * then store the results in a variable and resume the parent dialog.
     * Use this to [combine multiple dialogs into bigger interactions.](../conversations.md#composing-dialogs)
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * // define a profile collection dialog
     * let profileDialog = new BotkitConversation('PROFILE_DIALOG', controller);
     * profileDialog.ask('What is your name?', async(res, convo, bot) => {}, {key: 'name'});
     * profileDialog.ask('What is your age?', async(res, convo, bot) => {}, {key: 'age'});
     * profileDialog.ask('What is your location?', async(res, convo, bot) => {}, {key: 'location'});
     * controller.addDialog(profileDialog);
     *
     * let onboard = new BotkitConversation('ONBOARDING', controller);
     * onboard.say('Hello! It is time to collect your profile data.');
     * onboard.addChildDialog('PROFILE_DIALOG', 'profile');
     * onboard.say('Hello, {{vars.profile.name}}! Onboarding is complete.');
     * ```
     *
     * @param dialog_id the id of another dialog
     * @param key_name the variable name in which to store the results of the child dialog. if not provided, defaults to dialog_id.
     * @param thread_name the name of a thread to which this call should be added. defaults to 'default'
     */
    addChildDialog(dialog_id, key_name, thread_name = 'default') {
        this.addQuestion({
            action: 'beginDialog',
            execute: {
                script: dialog_id
            }
        }, [], { key: key_name || dialog_id }, thread_name);
        return this;
    }
    /**
     * Cause the current dialog to handoff to another dialog.
     * The parent dialog will not resume when the child dialog completes. However, the afterDialog event will not fire for the parent dialog until all child dialogs complete.
     * Use this to [combine multiple dialogs into bigger interactions.](../conversations.md#composing-dialogs)
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * let parent = new BotkitConversation('parent', controller);
     * let child = new BotkitConversation('child', controller);
     * parent.say('Moving on....');
     * parent.addGotoDialog('child');
     * ```
     *
     * @param dialog_id the id of another dialog
     * @param thread_name the name of a thread to which this call should be added. defaults to 'default'
     */
    addGotoDialog(dialog_id, thread_name = 'default') {
        this.addMessage({
            action: 'execute_script',
            execute: {
                script: dialog_id
            }
        }, thread_name);
        return this;
    }
    /**
     * Add a message template to a specific thread.
     * Messages added with `say()` and `addMessage()` will be sent one after another without a pause.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * let conversation = new BotkitConversation('welcome', controller);
     * conversation.say('Hello! Welcome to my app.');
     * conversation.say('Let us get started...');
     * // pass in a message with an action that will cause gotoThread to be called...
     * conversation.addAction('continuation');
     *
     * conversation.addMessage('This is a different thread completely', 'continuation');
     * ```
     *
     * @param message Message template to be sent
     * @param thread_name Name of thread to which message will be added
     */
    addMessage(message, thread_name) {
        if (!thread_name) {
            thread_name = 'default';
        }
        if (!this.script[thread_name]) {
            this.script[thread_name] = [];
        }
        if (typeof (message) === 'string') {
            message = { text: [message] };
        }
        this.script[thread_name].push(message);
        return this;
    }
    /**
     * Add a question to the default thread.
     * In addition to a message template, receives either a single handler function to call when an answer is provided,
     * or an array of handlers paired with trigger patterns. When providing multiple conditions to test, developers may also provide a
     * handler marked as the default choice.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * // ask a question, handle the response with a function
     * convo.ask('What is your name?', async(response, convo, bot) => {
     *  await bot.say('Oh your name is ' + response);
     * }, {key: 'name'});
     *
     * // ask a question, evaluate answer, take conditional action based on response
     * convo.ask('Do you want to eat a taco?', [
     *  {
     *      pattern: 'yes',
     *      type: 'string',
     *      handler: async(response, convo, bot) => {
     *          return await convo.gotoThread('yes_taco');
     *      }
     *  },
     *  {
     *      pattern: 'no',
     *      type: 'string',
     *      handler: async(response, convo, bot) => {
     *          return await convo.gotoThread('no_taco');
     *      }
     *   },s
     *   {
     *       default: true,
     *       handler: async(response, convo, bot) => {
     *           await bot.say('I do not understand your response!');
     *           // start over!
     *           return await convo.repeat();
     *       }
     *   }
     * ], {key: 'tacos'});
     * ```
     *
     * @param message a message that will be used as the prompt
     * @param handlers one or more handler functions defining possible conditional actions based on the response to the question.
     * @param key name of variable to store response in.
     */
    ask(message, handlers, key) {
        this.addQuestion(message, handlers, key, 'default');
        return this;
    }
    /**
     * Identical to [ask()](#ask), but accepts the name of a thread to which the question is added.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * @param message A message that will be used as the prompt
     * @param handlers One or more handler functions defining possible conditional actions based on the response to the question
     * @param key Name of variable to store response in.
     * @param thread_name Name of thread to which message will be added
     */
    addQuestion(message, handlers, key, thread_name) {
        if (!thread_name) {
            thread_name = 'default';
        }
        if (!this.script[thread_name]) {
            this.script[thread_name] = [];
        }
        if (typeof (message) === 'string') {
            message = { text: [message] };
        }
        message.collect = {
            key: typeof (key) === 'string' ? key : key.key
        };
        if (Array.isArray(handlers)) {
            message.collect.options = handlers;
        }
        else if (typeof (handlers) === 'function') {
            message.collect.options = [
                {
                    default: true,
                    handler: handlers
                }
            ];
        }
        // ensure all options have a type field
        message.collect.options.forEach((o) => { if (!o.type) {
            o.type = 'string';
        } });
        this.script[thread_name].push(message);
        return this;
    }
    /**
     * Register a handler function that will fire before a given thread begins.
     * Use this hook to set variables, call APIs, or change the flow of the conversation using `convo.gotoThread`
     *
     * ```javascript
     * convo.addMessage('This is the foo thread: var == {{vars.foo}}', 'foo');
     * convo.before('foo', async(convo, bot) => {
     *  // set a variable here that can be used in the message template
     *  convo.setVar('foo','THIS IS FOO');
     *
     * });
     * ```
     *
     * @param thread_name A valid thread defined in this conversation
     * @param handler A handler function in the form async(convo, bot) => { ... }
     */
    before(thread_name, handler) {
        if (!this._beforeHooks[thread_name]) {
            this._beforeHooks[thread_name] = [];
        }
        this._beforeHooks[thread_name].push(handler);
    }
    /**
     * This private method is called before a thread begins, and causes any bound handler functions to be executed.
     * @param thread_name the thread about to begin
     * @param dc the current DialogContext
     * @param step the current step object
     */
    runBefore(thread_name, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Before:', this.id, thread_name);
            if (this._beforeHooks[thread_name]) {
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);
                
                // to pass script into handler
                convo.script=this.script;

                for (let h = 0; h < this._beforeHooks[thread_name].length; h++) {
                    let handler = this._beforeHooks[thread_name][h];
                    yield handler.call(this, convo, bot);
                }
                // store TEMPORARELY in mustacheF the function loaded in values.mustacheF
                this.mustacheF=this.mustacheF||step.mustacheF;
            }
        });
    }
    /**
     * Bind a function to run after the dialog has completed.
     * The first parameter to the handler will include a hash of all variables set and values collected from the user during the conversation.
     * The second parameter to the handler is a BotWorker object that can be used to start new dialogs or take other actions.
     *
     * [Learn more about handling end of conversation](../conversations.md#handling-end-of-conversation)
     * ```javascript
     * let convo = new BotkitConversation(MY_CONVO, controller);
     * convo.ask('What is your name?', [], 'name');
     * convo.ask('What is your age?', [], 'age');
     * convo.ask('What is your favorite color?', [], 'color');
     * convo.after(async(results, bot) => {
     *
     *      // handle results.name, results.age, results.color
     *
     * });
     * controller.addDialog(convo);
     * ```
     *
     * @param handler in the form async(results, bot) { ... }
     */
    after(handler) {
        this._afterHooks.push(handler);
    }
    /**
     * This private method is called at the end of the conversation, and causes any bound handler functions to be executed.
     * @param context the current dialog context
     * @param results an object containing the final results of the dialog
     */
    runAfter(context, results) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('After:', this.id);
            if (this._afterHooks.length) {
                const bot = yield this._controller.spawn(context);
                for (let h = 0; h < this._afterHooks.length; h++) {
                    let handler = this._afterHooks[h];
                    yield handler.call(this, results, bot);
                }
            }
        });
    }
    /**
     * Bind a function to run whenever a user answers a specific question.  Can be used to validate input and take conditional actions.
     *
     * ```javascript
     * convo.ask('What is your name?', [], 'name');
     * convo.onChange('name', async(response, convo, bot) {
     *
     *  // user changed their name!
     *  // do something...
     * });
     * ```
     * @param variable name of the variable to watch for changes
     * @param handler a handler function that will fire whenever a user's response is used to change the value of the watched variable
     */
    onChange(variable, handler) {
        if (!this._changeHooks[variable]) {
            this._changeHooks[variable] = [];
        }
        this._changeHooks[variable].push(handler);
    }
    /**
     * This private method is responsible for firing any bound onChange handlers when a variable changes
     * @param variable the name of the variable that is changing
     * @param value the new value of the variable
     * @param dc the current DialogContext
     * @param step the current step object
     */
    runOnChange(variable, value, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('OnChange:', this.id, variable);
            console.log('OnChange:', this.id, variable);
            if (this._changeHooks[variable] && this._changeHooks[variable].length) {
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);
                for (let h = 0; h < this._changeHooks[variable].length; h++) {
                    let handler = this._changeHooks[variable][h];
                    // await handler.call(this, value, convo);
                    yield handler.call(this, value, convo, bot);
                }
            }
        });
    }
    /**
     * Called automatically when a dialog begins. Do not call this directly!
     * @ignore
     * @param dc the current DialogContext
     * @param options an object containing initialization parameters passed to the dialog. may include `thread` which will cause the dialog to begin with that thread instead of the `default` thread.
     */
    beginDialog(dc, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Initialize the state
            const state = dc.activeDialog.state;
            state.options = options || {};
            state.values = Object.assign({}, options);
            // Run the first step
            return yield this.runStep(dc, 0, state.options.thread || 'default', botbuilder_dialogs_1.DialogReason.beginCalled);
        });
    }
    /**
     * Called automatically when an already active dialog is continued. Do not call this directly!
     * @ignore
     * @param dc the current DialogContext
     */
    continueDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // Don't do anything for non-message activities
            if (dc.context.activity.type !== botbuilder_1.ActivityTypes.Message) {
                return botbuilder_dialogs_1.Dialog.EndOfTurn;
            }
            // Run next step with the message text as the result.

            console.log('*** continueDialog called' );

            return yield this.resumeDialog(dc, botbuilder_dialogs_1.DialogReason.continueCalled, dc.context.activity.text);
        });
    }
    /**
     * Called automatically when a dialog moves forward a step. Do not call this directly!
     * @ignore
     * @param dc The current DialogContext
     * @param reason Reason for resuming the dialog
     * @param result Result of previous step
     */
    resumeDialog(dc, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            // Increment step index and run step

            // >>>> RECOVER state from dc.activeDialog.state that can be different from last step ??
            const state = dc.activeDialog.state;
            console.log(' resumeDialog called state is ',state);
            return yield this.runStep(dc, state.stepIndex + 1, state.thread || 'default', reason, result);
        });
    }
    /**
     * Called automatically to process the turn, interpret the script, and take any necessary actions based on that script. Do not call this directly!
     * @ignore
     * @param dc The current dialog context
     * @param step The current step object
     */
    onStep(dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            // Let's interpret the current line of the script.
            const thread = this.script[step.thread];
            // Capture the previous step value if there previous line included a prompt
            var previous = (step.index >= 1) ? thread[step.index - 1] : null;

            /* cases on step.result :
                - null : when coming from   startdialog, replay
                             normal repeat will have a no result with no goon so no msgSent will be set so current handler will emit msg prompt
                             special repeat UU will have too a no result with also a no  goon 
                             startdialog will have too a no result with also a no  goon 

                - string:                   runStep, continuedialog,
                - obj=step.values               gotothread (will use goon to recover userturn) , return from child, resumedialog ???


            so  if null msgSent= null
                if string :
                    - set msgSent=step.index-2 : the step before the previous step 
                    - userTurn=step.result
                    if find state.goon :
                        - msgSent=state.goon

                if obj 
                    
                    if((recLTurn||step.index>0)&&(!step.msgSent) // use results in next step if exists (step.msgSent not null ) or 
                                                                 // if index=0 recLTurn
                            step.state.goon=step.msgSent; 
                            runStep(dc, step.index+1,,,,)  >>>  will call onstep with string=result

                NB  A case  : if condition dont match with msgSent = step before the analizing condition step >>>>>  send a reply request
                                    if msgSend<index-1
            */


            // if this is index 0 try to process the userturn coming from previous thread 

            console.log('\n\n ***** onStep starting  at  index: ',step.index,'  thread : ',step.thread,
            '\n   coming  text/result : ',step.result ,' ( isstring : ',typeof step.result === 'string',' ) ',
            '\n if result is string , we test previous step condition at index ',step.index-1,' using  result/answere  that if state.goon ( = ',step.state.goon,' ) < previous index ( = ',step.index-1,' ) can  comes from a step before previous step '
             );

            let msgSent=-777,// text result do not available
            state=step.state;// 
            let goonDir = true;// default : do goon(mixedinitiuative) tech

            if(
                step.result&&
                (typeof step.result === 'string' || step.result instanceof String)){// >>>>> register last user turn on status 

             //   console.log(' onStepstarting , found string setting msgSent : ',step.index-1);

                //okok :  can come from a runstep(....result) from a dc begindialog or from a step calling runStep(index+1,,result) but in this case we set goon as msgSent 

            step.state.userTurn=step.result;// *** if this step will gotothread ( and begindialog,resumedialog ?), receiving step will recover that text .( )
            // >>>> step.state.userTurn can be nulled by onChange !!!!!!
 
            // msgSent=step.index-1;// the
            msgSent=step.index-1;// the
            //else step.state.userTurn=null;// when will i reset that ? never ? 

            // moved from runstep :

            // goon should warn that we goon to next step using a previous msg prompt , 
            // >>>>>>>>>>>>>>>>  so shoud be index-1 otherwise should be index -2 ??
            //if(state.goon||state.goon<=step.index-1){msgSent=state.goon;// usually step run with a user answare to msg of step with index-1 
            if(state.goon&&state.goon<=step.index-1){
                msgSent=state.goon;// usually step run with a user answare to msg of step with index-1 (previous msg)
                console.log('  GOON detected : last step fired a runstep() with state.goon (so result is a speech response of a msg before previous step on which we are testing condition), thread: ',step.thread,'\n    current index is ' + step.index ,' previous  index ( where we test the condition ) is ' + step.index-1 ,' setgoon is set in TTT when goon with a user answere referring to a older msg index: ',state.goon,' text is ',step.result);
                state.goon=null;// reset
            }
            // else msgSent=state.goon;???????????
            }
            console.log('       , msgSent was set to ',msgSent);
     
            step.msgSent=msgSent;

        

            if (step.result && previous && previous.collect) {
                if (previous.collect.key) {
                    // capture before values
                    let index = step.index;
                    let thread_name = step.thread;
                    // capture the user input value into the array
                    if (step.values[previous.collect.key] && previous.collect.multiple) {
                        step.values[previous.collect.key] = [step.values[previous.collect.key], step.result].join('\n');
                    }
                    else {
                        step.values[previous.collect.key] = step.result;// here step.result can be   text or obj
                    }
                    // run onChange handlers
                    yield this.runOnChange(previous.collect.key, step.result, dc, step);
                    // did we just change threads ? if so, restart this turn
                    if (index !== step.index || thread_name !== step.thread) {
                        return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                    }
                }
                // handle conditions of previous step 

                // logging 
                function ttest(tomatch,test){
                    console.log(' conversation trying matching text ',tomatch,' with patt ',test);
                    return tomatch.match(new RegExp(test, 'i'));// test='stay*\w*\s(\w*)' will return rematch=[],  in rematch[1] is the word after stay*
                }


                if (previous.collect.options) {
                    var paths = previous.collect.options.filter((option) => { return !option.default === true; });
                    var default_path = previous.collect.options.filter((option) => { return option.default === true; })[0];
                    var path = null;
                    for (let p = 0; p < paths.length; p++) {
                        let condition = paths[p];
                        let test;
                        let notest = false;
                        let patt;
                        let tomatch = step.result, storemat = null;
                        if (condition.type === 'string') {
                           // test = new RegExp(condition.pattern, 'i');

                            if (ttest(tomatch,condition.pattern)) {
                                console.log(' MATCH Detected : string condition ( number ',p,')matched at step index ', step.index,', condition : ', condition);

                                path = condition;
                                break;
                            }


                        }
                        else if (condition.type === 'regex') {
                            console.log('\n condition matching debug : $$ case pattern is  ', condition.pattern);






                                        /* moved to ext func 
                                            function looseJsonParse(templ,vars){//extract in cond string a vars . format  xxxx&&vars.excel.....&&yyyy
                                            // see evalmozilla.js, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
                                            // call  ftempl=looseJsonParse(template,Object.assign({},context.vars,{aa}));
                                            // template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated

                                                // usually used in case we want to generate same text without use a onchange 
                                                // or also when in a msg we want to use a {{}} a context var depending from past status  
                                                // or in a condition we want to test not the user speech but the passed var got 

                                             let ioa = templ.indexOf('&&'),fcorpus,fc;
                                              let templP=templ.split('&&');

                                               //      console.log('looseJsonParse : templP is :',templP);
                                             //if (ioa > 0){let ioa1 = templ.indexOf('&&',ioa+3);
                                              //  if(ioa1>0)fcorpus = templ.substring(ioa+2, ioa1);}

                                              if(templP.length==3){
                                              // evaluate fcorpus in context 
                                                fc=templP[1];
                                                console.log('looseJsonParse : fc is :',fc);
                                                let myf='"use strict";' + fc;
                                                 let calc;
                                                // calc=Function(myf)();
                                                //calc=Function('"use strict";' + fc)();
                                                 //calc=Function( fc).call(vars);
                                                //calc=Function( fc).call(vars);
                                                calc=eval( fc);
                                                // OK calc=eval(myf);
                                                //   console.log('looseJsonParse  calc :',calc);
                                                if(calc)return templP[0]+calc+templP[2];
                                          
                                              }
                                              return templ
                                                                                  
                                             // return Function('"use strict";return (' + obj + ')')();
                                            }*/
                                        

                           function jVar(cod,vars){// returns the value of a cod vars , ex cod='avarwithnopoint' returns vars.matches[cod] ,otherwise return code vars ( start with vars.)
                            /*if(!cod)return rr, where rr is :
                            
 
                            condition regex patt example : $$mod_wh:where-dove|che posto|luogo&how-come|modo|devo|fare&when-quando|ora|orario|mattina|pomeriggio|sera|mattina
                                > will be cod='mod_wh'
                            
                                so, 
                                do case on regex patt in a ask condition :
                                1: if cod start with : $$ or $% or $$$    followed by xx&yy  :
                                    patt : $$cod&yy 
                                    >   cod is a model name(usually 'mod' followed by no points), jVar  returns : vars.matches[cod] (see addMatcRes for matches format )
                                2: if cod start with : $$ or $% or $$$    followed by vars.a.b.c&yy 
                                    >  cod=vars.a.b.c  is a obj name , jVar  returns : vars.a.b.c 

                            */
                               let qobj=cod.split('.');
                               if(qobj.length<2){// case 1 , xx is a model name so returns 
                                   
                                if(vars.matches[cod])return vars.matches[cod].match;// (see addMatcRes , model case ,  for matches format )
                               else return null;
                            }else{

                                return getCodedVar(vars,qobj);
                               }
                               function getCodedVar(vars,qobj){return iterdepl(vars,qobj,qobj.length)}
                               function iterdepl(vars,namwp,pos){// pos=point position,'vars.askmodel.match.pippo' >  namwp= ['vars','askmodel','match','pippo'] initial pos=namwp.length 
                               // will return vars obj as required by literal string namwp
                               let ll=namwp.length,step=ll-pos;// step =0 ... ll-1     max :  ll-1=step=ll-pos  >> pos=1
                               if(step==0){if(namwp[step]=='vars')  vars=vars;// must start with vars.
                                            else return null;}
                                else{

                                    vars=vars[namwp[step]];
                                    if(vars);else return null;
                                }

                                if(pos<2){// at the end 
                                        return vars;
                                }else{
                                    pos--;
                                        // here pos>=1
                                        return iterdepl(vars,namwp,pos);

                                }

                               }



                           }




                            if (condition.pattern.substring(0, 2) == '$$' || condition.pattern.substring(0, 2) == '$%') {// todo add a $% that means try match , register , but no stop current condition testing
                                //  console.log(' condition matching : $$ case pattern is  ',condition.pattern, ' patt is : ',condition.pattern.substring(2,condition.pattern.length));
                                let linematch=condition.pattern.substring(0, 2) == '$$';// if model matched match the line if not previously done, then if matched route ($$ case)  otherwise goon to test all other conditions
                                let entity;

                                // do a version x  if(condition.pattern.substring(0,3)=='$$%')// recover the value values[ioafild].match
                                if (condition.pattern.substring(0, 3) == '$$$')// recover the value  values.matches[ioafild]
                                {// regex: '$$$location&gigi||luigi  patt='gigi||luigi'   ioafild='location'
                                    let ioa = condition.pattern.indexOf('&');
                                    if (ioa > 0) {
                                        patt = condition.pattern.substring(ioa + 1, condition.pattern.length);
                                        let ioafild;// &&&

                                        ioafild = condition.pattern.substring(3, ioa);
                                        //tomatch = step.values.matches[ioafild];// to test if tomatch  match with pattern patt  
                                        tomatch=jVar(ioafild,step.values);// must be a string (the item value/key , not the voice name )
 
                                        console.log(' condition try matching : $$$ case ioa ', ioa, ' ioafield ', ioafild, ' tomatch ', tomatch, ' patt ', patt);
                                        if(!tomatch)notest=true;
                                    } else notest = true;


                                    

                                    //test = new RegExp(patt, 'i');
    
    
                                    // TODO: Allow functions to be passed in as patterns
                                    // ie async(test) => Promise<boolean>
                                    if (!notest && ttest(tomatch,patt)) {
                                        console.log('  MATCH Detected : $$$ condition  ( number ',p,') matched  at step index ', step.index,', condition : ', condition);


                                        path = condition;
                                        break;
                                    }





                                }// ends $$$ case 
                                 else {// $$ (test and condition route ) or $% (test and not condition route ) or $$% $%% (% in 3rd position means to test anyway )
                                    // add a $$mario-mario*&second item ....
                                    // for   {nextitem=condition.pattern.indexOf('&');  No ?  just one item x condition ?!!!

                                    // >> better put the matched result in a dedicated value.matches.entity
                                    // the match can be done in many condition or just one :
                                    // $$entity_name:ma-mario*&gi-giovanni :
                                    // entity='ma' or 'gi'

                                    // a json format can be used !
                                    // $$entity_name:pattArray     so :
                                    let itr = condition.pattern.indexOf(':'), pattArray,pArray;//  pattArray='item1-pippo!poppo*&item2-parerino&..',pArray={item1:{patt:'pippo!poppo*',,,},item2:{patt:'parerino',,},,}

                                    let sk_=1,retest,chmatch,
                                    prevMat;
                                    if((retest= condition.pattern.charAt(2)=='%'));// overwrite test
                                    else if (chmatch= condition.pattern.charAt(2)=='ยง'){
                                        //prevMat=step.values.matches[entity]
                                        ;}// check if matched changed , to do , usefull ??? , only if  $%ยง : if dont match leve previous !
                                    else sk_=0;// no third ctl char
                                    if (itr > 0) {// a model match with entity name declared : $XYentityname

                                        if(condition.pattern.charAt(itr+1)==':'){// excel declaration : $$entity_name::
                                            entity = condition.pattern.substring(2+sk_, itr);
                                            if(step.values.excel[entity]&&step.values.excel[entity].model)pArray=step.values.excel[entity].model;// get voice entity name from excel


                                        }else{// in line declaration >  $$entityname: or $$%entityname: or $%entityname: or $%%entityname:




                                        pattArray = condition.pattern.substring(itr + 1, condition.pattern.length);//substring(itr,nextitem-1)
                                        entity = condition.pattern.substring(2+sk_, itr);

                                        }

                                    } else{ entity = previous.collect.key;
                                        pattArray = condition.pattern;
                                    }
                                    // pattArray='ma-mario&lu-luigi|gigi'



                                    // todo if $% and alredy matched we dint need to retry matching !!!!!!!!!!
                                    let matched=false,// matched before or in this test 

                                    rematch;// the regex extraction ( due to ()) used in  addMatcRes , bad name !!

                                    // gives error : if(chkMatcRes(entity)==null){ //  if didnt match do it 
                                    // so :
                                        if(!retest&&chkMatcRes(entity)){
                                            //  it already matched , so if is $$ we must stop testing the loop and route
                                           
                                            // if chmatch store previous, if exists and we dont match current restore past match
                                            if (chmatch) prevMat=step.values.matches[entity];// is also :matched=false
                                            else {
                                                 matched=true;
                                            
                                                if(linematch)path = condition;// do not route if is $%  0503
                                            }

                                        }

                                        if(!matched) {//  if didnt match , or retest , or chmatch to do , do it 
                                            step.values.matches[entity]=null;// reset previous match 

                                    matched=false;
                                    let itemb;
                                    let ii=0,itr1;// when 0 stop while
                                    if(pArray)itr1=Object.getOwnPropertyNames(pArray);
                                    else itr1=pattArray.split('&');

                                    for(ii=0;ii<itr1.length;ii++){// gh for all item in model test it 
                                    /* while till & ends pattArray=pattArray
                                    itr=pattArray.indexOf('&');
                                    if(itr>0){ pattArray.substring(itr+1,pattArray.length);}*/

                                    if(pArray){
                                        patt = pArray[itr1[ii]].patt;
                                        storemat = itr1[ii];
                                        console.log(' condition try matching : $$ case , ii: ',ii,' storemat(matched item value/name)  is  ', storemat, ' patt is : ', patt);
                                    }else{
                                    let sar=itr1[ii].split('-');//itr1[ii].indexOf('-');
                                    if (sar.length > 1) {
                                        patt = sar[1];
                                        storemat = sar[0];
                                        console.log(' condition try matching : $$ case , ii: ',ii,' storemat(matched item value/name)  is  ', storemat, ' patt is : ', patt);

                                    } else notest = true;
                                    // end for 
                                    }

                               // test = new RegExp(patt, 'i');


                                // TODO: Allow functions to be passed in as patterns
                                // ie async(test) => Promise<boolean>
                                
                                if (!notest &&  (rematch= ttest(tomatch,patt))) {// match if ttest returns not null rematch. rematch[1]>matches.entity.
                                    // ok : 
                                    console.log('  MATCH Detected :$$ or $% condition, at step ',step.index, ',: model  ',entity,' matched item ',storemat,' id ',ii,' extracts: ',rematch);
                                    step.values.__conf=step.values.__conf||'';// confirm  the user matched something 

                                    if(step.values.excel[entity]&&step.values.excel[entity].vmatches)step.values.__conf+=step.values.excel[entity].vmatches[storemat];// get voice entity name from excel
                                    else step.values.__conf+=storemat;

                                    if(linematch)path = condition;// do not route if is $%
                                    matched=true;break;// break ii loop
                                }else{// 
                                   //  addMatcRes(false,entity);
                                }

              
                            }// gh  end ii for , test item in model
                            /* 
                            function addMatcRes(mat,entity,storemat){// register last turn match asked with $$ or $% result 
                                // mat      : true if entity is matched
                                // entity   : model name ($$ case) otherwise condition  index 
                                // storemat : matched item value 

                                // so matches can be available in out as step=this ,this.values.askmatches[thisaskmatchesname].match/nomatch='entity1|entity2'
                                let mf;
                                if(mat)mf='match';else mf='nomatch';

                                // register only model matches : 
                                if(mat)step.values.matches[entity] = storemat;// register under values.matches.entity=itemvalue
 
                                step.values.askmatches[previous.collect.key]=step.values.askmatches[previous.collect.key]||{match:[],nomatch:[]};
                                // if(step.values.askmatches[previous.collect.key][mf])
                                    step.values.askmatches[previous.collect.key][mf].push({key:entity});
                                // else step.values.askmatches[previous.collect.key][mf] = {key:entity};// first value
                                //step.values.askmatches[previous.collect.key].match += entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                           
                            }*/



                            /* mng summary : register the match no matc :
                                - if matches register the ask matches 
                                    and the 
                            */
                            if(matched){
                            if (storemat) {// if there is the entity value , so in case of $$ , a model match 
                                /*
                                step.values.matches[entity] = storemat;// register under values.matches.entity
                                step.values.askmatches[previous.collect.key]=step.values.askmatches[previous.collect.key]||{};
                                if(step.values.askmatches[previous.collect.key].match)step.values.askmatches[previous.collect.key].match='|'+entity;
                                else step.values.askmatches[previous.collect.key].match = entity;
                                //step.values.askmatches[previous.collect.key].match += entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                                */


                               // if(prevMat);// if there was a previous match to check and matches:  rebuild matching status , as was matched from new
                               if(chmatch){// also here do routing to new match also if was the same as before
                                if(linematch)path = condition;// do not route if is $%  0503
                                addMatcRes(true,entity,storemat,ii,linematch,rematch);// rebuild anyway

                               }
                               else   addMatcRes(true,entity,storemat,ii,linematch,rematch);// linematch means to route on this condition , if maches
                            }else addMatcRes(false,entity,null,ii,linematch);
                            }else {
                                if(prevMat){
                                    // if there was a previous match to check leave the previous matching status , but do not consider matched now this condition
                                    console.log('  check MATCH: no new match so just leave previous match status,  at step index ', step.index,' condition : ',condition);
                                                                                // if chmatch store previous, if exists and we dont match current restore past match
                                    step.values.matches[entity]=prevMat;//  restore previous, do nothing
                                }
                                else addMatcRes(false,entity,null,ii,linematch);

                            }

                        }// end if didnt match do it 
                            if(linematch&&matched)break;// not in $% case (linematch is false)

                                }// end $$ case

                            } else {// no $$$ , no $$ ,no $% case

                                patt = condition.pattern;

                                //test = new RegExp(patt, 'i');

                                // TODO: Allow functions to be passed in as patterns
                                // ie async(test) => Promise<boolean>
                                if (!notest && ttest(tomatch,patt)) {
                                    console.log('  MATCH Detected : regex condition matched  at step index ', step.index,' condition : ',condition);
                                    /*if (storemat) {
                                        step.values.matches[entity] = storemat;// register under values.matches.entity

                                        step.values.askmatches[previous.collect.key].match = entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                                    }*/

                                    addMatcRes(true,null,p,true);// if a condition with no model matches we register a match {ind:4} and not {key:value}


                                    path = condition;
                                    break;
                                }

                            }// end no $$$ , no $$ ,no $% case

                            function addMatcRes(mat,entity,storemat,storeMId,routing// routing=linematch is true if not $% case ( not routing case )
                                        ,rematch// the regex extraction 
                                        ,reset// reset matches

                                        ){// register model/entity match, last turn match asked with $$ or $% result 

                                /* if condition with entity ( $$ or $% case )  we register  a model match ( entity instance  = itemname) :
                                      adding  {key:entity} to  values.askmatches.askname.match array (  values.askmatches.askname={match:[{},,,,],nomatch:[]} )
                                      + setting                         values.matches.entity={match:itemvalue}
                                                 if exist def in excel : values.matches.entity={match:itemvalue,vmatch:vars.excel.entity.vmatch,data:rematch[1]=matches.entity} 



                                      or not matched :
                                      adding {key:entity} to  values.askmatches.askname.nomatch array (  values.askmatches.askname={match:[{},,,,],nomatch:[]} )

                                 if a condition with no model matches we register a match {ind:4} (and not {key:value})
                                    adding {ind:4} to  values.askmatches.askname.match array (  values.askmatches.askname={match:[{},,,,],nomatch:[]} )
                                    if do not match ,do nothing  

                                */

                                // mat      : true if entity is matched, false 
                                // entity   : model name ($$ case) otherwise null condition  index 
                                // storematch, storeMId is 
                                //              if condition is $$ $% ( model match) : the name/value matched () entity not null),
                                //              storeMId is the id of matching condition 
                                
                                /*  *******    master/desire entity simple relation with ask conditional described as $$ 

                                          the entity/model should be  is defined somewhere (in excel ...)
                                          in this very simple implementation the view is not bind to the model ( id/name/voicepattern/shortdescriptio)
                                          but just set by $$ condition munually copyng the name/pattern field 
                                          in future we should do $$mod:areference on the model description file set somewhere in 
                                              the model/field dialog description bind to a static (file) descriptio or to a dyn db schema
                                          here the where model are just the space of a relational where entity put directly in a col of master entity ( desire entity)
                                              whith its id or name ( both are key)
                                          so to make sintetic : $$....reflect the name-voicepattern of a implicit model whose id/name is put in a where field of the related master desire entity
                                    ******
                                */



                                // storemat : matched model item name/value ($$ case), otherwise condition  index

                                // old : so matches can be available in out as step=this ,this.values.askmatches[thisaskmatchesname].match/nomatch='entity1|entity2'
  
/*
                                                        askmatches=convo.vars.askmatches,/* askmatches={aask:{

                                                                match:'aval',
                                                                matches:[{key:'aval'},{key/ind:oneindex?},,],// models matches  , one routing (std, $$,$$$, no $%) index 
                                                                nomatches:[{key:'aval'},,,],// only models
                                                                ... some onchange added fields , ex : matched complete desire param ...
                                                            }}
                                                    modmatches=convo.vars.matches.amodel={match:itemvalue-key,vmatch:voicenameofitem,data:xqea}

*/


                                console.log(' ** addMatcRes called ,mat,entity,storemat, routing',mat,entity,storemat,routing)

                                if(reset){

                                    if(entity)step.values.matches[entity]=null;
                                        step.values.askmatches[previous.collect.key]=null;

                                    return;
                                }

                                let mf,amatch,amatchId;
                                if(mat)mf='matches';else mf='nomatches';
                                if(entity)amatch={key:entity};// the model/entity name matched/not matched
                                amatchId={id:storeMId};// normal condition match with no model 

                                // register only model matches : 
                                if(mat&&entity){step.values.matches[entity] ={match: storemat};// register under values.matches.entity=itemvalue
                                step.values.matches[entity].mid=storeMId;
                                    if(step.values.excel[entity]&&step.values.excel[entity].vmatches)step.values.matches[entity].vmatch=step.values.excel[entity].vmatches[storemat];// get voice entity name from excel
                                    if(rematch&&rematch[1])step.values.matches[entity].data=rematch[1];// see ttest() return ( returns regex catch () ) ,store matched data to run on a routed displayng dyn key onchange (the thread msg on a $$ condition gotothread )
                                }
                                // nb step.values.askmatches[previous.collect.key] can be alredy filled with short bl status (like qs in reload after a web form)
                                step.values.askmatches[previous.collect.key]=step.values.askmatches[previous.collect.key]||{matches:[],// also condition with $%
                                                                                                                            match:null,// condition not $% (so routing)
                                                                                                                            mId:null,
                                                                                                                            nomatches:[]};// adds only $% or $$  case
                                step.values.askmatches[previous.collect.key].matches=step.values.askmatches[previous.collect.key].matches||[];
                                step.values.askmatches[previous.collect.key].nomatches=step.values.askmatches[previous.collect.key].nomatches||[];
                                
                                // if(step.values.askmatches[previous.collect.key][mf])
                                    step.values.askmatches[previous.collect.key][mf].push(amatch);
                                    if(routing){ step.values.askmatches[previous.collect.key].match=amatch;step.values.askmatches[previous.collect.key].mId=amatchId;}
                                // else step.values.askmatches[previous.collect.key][mf] = {key:entity};// first value
                                //step.values.askmatches[previous.collect.key].match += entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                           
                            }
                            function chkMatcRes(entity){// check if model entity matched, usefull in $$ and  $%  
                                // entity   : model name ($$ case) otherwise null condition  index 
                                // returns matched model item name/value ($$ case), otherwise null

                                // debug 
                                if(step.values.matches);
                                else  console.error('  ERR   chkMatcRes cant find values.matches !!! on entity  ', entity);


                                if(entity)if(step.values.matches[entity]) {// register under values.matches.entity=itemvalue
                                    console.log('chkMatcRes : the entity: ' , entity,' already matched item: ', step.values.matches[entity]);
                                    return step.values.matches[entity];

                                }
                                return null;
                            }




                        }

                    }// ends for (p= ....)
                    // take default path if one is set

                    // ****************  step.msgSent null ??????????????????????

                    console.log('\n previous step  at index ', step.index,' finished matching conditions , match is ', path != null,', on user answere  to msg at index :', step.msgSent, ' \ncondition matched :  ' , path, ' , default_path=   ', default_path);

                    if (!path) {

                        console.log(' previous  condition dont matched,   msg was sent before this condition test step msg  ', step.msgSent < step.index - 1);// sent if msgSent=1 index=2, msgSent=1 index=3

                        // no :  better after this {}, so anywhere both match or not match , if next (continue) 
                        // >>> A case : se non ho un match condition col msg previous we mast sent the msg prompt

                        // >>> todo  if(step.msgSent means msgSent is set ???
                        //  AND add a flag to decide if do or not do the retry

                        // recover excel directive x this step ask 


                        /* TODO  TODO now askmatches are in .direc. !!!!!

                        if (step.values.excel && step.values.excel[previous.collect.key]
                            && !step.values.excel[previous.collect.key].goon) goonDir = false;
                            */
                           if (step.values.direc &&step.values.direc[previous.collect.key] && step.values.direc[previous.collect.key].loopDir
                            && step.values.direc[previous.collect.key].loopDir.goon==false) goonDir = false;

                        // if (goonDir && default_path.action == 'next' && step.msgSent && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt
                        // if (goonDir && default_path.action != 'repeat' && step.msgSent && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt


			if (goonDir && default_path.action == 'next' && step.msgSent && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt


	/*DO GOON ( do a chance to condition to match also the previous step user answere ) Management :

    
	fase : durante il process di un step B faccio testing del  previous step A
	se , durante il testing dei condition di un previous step A su answere del msg del previous msg A o un answere precedente passato durante precedente  current process dello step A
	if a user answere massage is passed to a step ( also in index 0 , anyway will be tested as previous in next step) (result or recovering a goto passing message or begindialog )and is  :
		During the previous step testing A ( current is step+1)
		-  too old (step.msgSent < step.index - 1)   .   NBNB : if it were too old  should not  be tested conditions ????
		- conditions  didnt match or is null set
		- default set to continue ( so of is a goto we dont goto if we didnt match on a previous step answere , we also must dont match with present step answere !)


    > force default to replay ( To test condition on user answere to its proper step  msg )
    
update :

 in a previous step A we see if 


	*/


                            console.log('  (a default apply because none of previous  condition at prevIndex ', step.index - 1, ' matched  \n  as : \n - direc[previous.collect.key].loopDir.goon==false , \n - the def condition is next/continue AND \n - we tested condition on user answer to a msg emitted before the prevIndex msg   (msg index is ', step.msgSent, ' ) \n > we retry the step at index ', step.index - 1
                                , ' coming from a reply the runstep will be called with a null result so wiil emit the previous  msg prompt'
                                + ' also gotothread will call runstep with a null result ( and index =0 )but as we find  like a gotothread  with a null result ');
                            //path =default_path;

                            // >>>>>>>   ERROR we cant change default_path.action because will be permanent !!!!!
                            // try correct with peach RE
                            // default_path.action='repeat';

                            // clone values , dc.activeDialog.state different from step.state ?
                            path = Object.assign({}, dc.activeDialog.state.values);
                            path.action = 'repeat';

                            // OKOK this is a special repeat UU : msgSent dont match so ask normal step msg 
                            // normal repeat will have a no result with no goon so no msgSent will be set so current handler will emit msg prompt
                            // special repeat will have a no result with also a no  goon 

                            //  step.state.goon=step.index-3;//useless as next step will be called with result=null to issue the index-1 msg 
                            // normal repeat step.msgSent=step.index-1;

                        }

                        else path = default_path;// peach RE
                    }
                    if (path) {// it matches or default , !! ok

                        if (path.action !== 'wait' && previous.collect && previous.collect.multiple) {
                            // TODO: remove the final line of input
                            // since this would represent the "end" message and probably not part of the input

                        }

                        console.log(' convo after got a path to go exec handleAction with path :',path);
                        var res = yield this.handleAction(path, dc, step);
                        if (res !== false) {
                            console.log(' convo after executed handleAction  returned not false so return ');
                            return res;
                        }
                        console.log(' convo after executed handleAction  returned  false so goon with current handler  ');
                    }
                }
            }

            // ****  Handle the current step

// hotel customization 
         
           //  when receiving text (user answere put in userTurn , that can be used in onStep usually at index 0 )
           // >>>>>  better set status.userTurn in caller  dc.xxxDialog()
           // if(Object.prototype.toString.call(myVar) === "[object String]")

           // add a check from  a description flag : if(dynfield.getprevious turn on entering a new thread)
            
            /*
           console.log(', ** setting last user turn , index: ',step.index, ' result : ',step.result ,' condition ',typeof step.result === 'string',step.result instanceof String);

                if(typeof step.result === 'string' || step.result instanceof String){// register last user turn on status 
                step.state.userTurn=step.result;
                }else step.state.userTurn=null;
            */
            let recLTurn=false;// some text recoverED from previous STEP THAT CAME TO THIS THREAD FROM A BEGINDIALOG OR GOTOTHREAD,  turn status step.state.userTurn
            if(goonDir&&step.index==0



		){// in starting a new thread (after a goto) if we have some condition try to recover last user turn answere in the current cmd to test condition also with previous user answere

                // at index 0 we can have null if retrying or a beging dialog  (must not recover) or object  if coming from a goto thread (should try to recover)
   
   //             console.log(', ** this previous step of index 0, recovering last user turn : with isstringresult =',typeof step.result == 'string',' isresultNull: ',step.result ==null);//,' . String: ',!step.result instanceof String);

                if(step.result !=null&&typeof step.result != 'string' ){
                    // so is obj , coming from gotothread ( also  coming from a child or resumedialog ? ), 

                    // todo verify that begindialog and replacedialog do not se step.result as a obj . we will manage that case differently 
                    //          >>>>>>>>>>>>>>>> in future we can have begindialog with string result
                    // coming from gotothread is obj , 
                    // problem both coming from begindialog(todo : change relaying the last user turn) and retry , both are null  null 
                    console.log('\n ** onstep Handle the current index 0 step , as result is obj (so gotothread or returning from a child ( replacedialog too ???) )\n  so ( SETting recLTurn=true ) recovering last user turn  text from state.userturn :',step.state.userTurn);
 
                    // now (after done previous collect match) we can change the result : 
                    if(step.state.userTurn){// do that only in goto case and userTurn is set 
                    step.result=step.state.userTurn;
                    step.state.userTurn=null;// reset ?
                    // >>>>>>>>>>>
                    // alredy set step.msgSent=0;// as came from this msg so chain next step 

                    recLTurn=true;
                    step.msgSent=-1;// added 03022020
                }
                }//else state.userTurn=null;
                else if(typeof step.result == 'string'){// is a begin dialog with string result : can forward too
                    recLTurn=true;
                    step.msgSent=-1;// added 03022020, means the user answere step.result cames from a prompt issued by a step before step 0 
                } 
                // else is null ( probably just a repeat, result is null  )
            }

            if (step.index < thread.length) {
                let line = thread[step.index];
                //console.log('convo onstep Handle the current step ,step is ' + JSON.stringify(step, null, 4) ,' text is ',step.result);



                // ******************+  step.msgSent and step.result  are undefined 

                //console.log('convo onstep Handle the current step ' + step.index ,' of ', thread.length,'steps on thread ',step.thread,' , recovered a user answere :',step.result,' to msg  of index ',step.msgSent,' ( if smaller (',recLTurn,') is a older step msg answare !) ');
                console.log('convo onstep Handle the current step ' + step.index ,' of ', thread.length,'steps on thread ',step.thread,
                ' ,\n after tested  condition on previous step ',step.index-1,' with a user answere :',step.result,' to msg  of index ',step.msgSent,' ( if smaller (',recLTurn,') is a older msg then the tested condition !) ');

                // 062019 goon trying to match more ask with a single user utterance 
                step.state.goon=null;// 
                // if(step.values.goon&&step.values.goon==true&&step.index>0)

                /*  ????
                 todo if recLTurn we can goon if there is condition to valuate !!!!!!!!!!!!
                    verify also there is a next step 
                    > are there some cond on next step ? thread[step.index+1].collect.options/key
                */
                    

                if(goonDir&&(recLTurn||step.index>0)&&(step.msgSent >-2// use results in next step if exists (step.msgSent not null, better > -2 ) or 
                                                            // if index=0 recLTurn will decide to goon or not

                   // useless  ||step.msgSent>=step.index-1

		&&thread[step.index].collect // and we have some condition to test also on previous user answere
                    
                    ))// if index > 0 do not send msg, it will be sent as repeat next step if dont match
                { // TTT


/*
 ***************************  GOON mng summary  ( TO review if is begindialog or resumedilog or returning after a child) 

DO GOON ( do a chance to condition to match also the previous step user answere ) if

- step with index >0 :

    if a step.result is not nulled string after onchange we test condition
    - there is some condition to test
    AND
    - the action selected was continue (so also after a check for at least one condition matched , otherwise we force a default with repeat)
    we came to manage current handler and we goto next step with present step.result  without prompting step msg for a new user answere
    
    IF  step.result is obj with index >0 ( a resume or a child return )
    after onchange we CANT do test condition 
    so ( to complte this comment )
    .........   ( seems we must do standard msg prompt to the user )
                    

    ( old comment :
	we didnd force default replay on condition 
		- a default continue   after 
        -  none condition was matched on a not null condition set 
    )


- step 0 
         we dont do any previous testing 
         when the thread was called (after begin cb) 
                by a gotothread ( or return from a child)  ( step.result is obj) with a previous step user answere put in step.state.userTurn
                OR
                by  begindialog with a previous step user answere put as string in step.result

                    - if this index 0 step has conditions to test 
                            >> we  can recover previous user answere put in step.state.userTurn ( and so set  recLTurn=true and GOON to test condition  ) 
                    -else we issue the step 0 msg in order to test condition with user answere to msg




*/



                       console.log(' > Ending current Step Handling without prompting: GOON next Step  ',step.index+1, ', because we do not retrying because of A ,\n A means :we dont match the condition on a step of index ',step.index-1 , ' on  msg of index ',step.msgSent,' that was a msg of a step before \n');
                     step.state.goon=step.msgSent;  // okok:
                                                    // inform following calling runstep ( the (current) index in runstep is this index +1) that :
                                                    //  - the msg/prompt the user answered (msgSent=currrentindex-2)was not previous=current_index-1 but  a step before 
                                                    //  - so if the step dont match the previous must replay/retry

                    //return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.result);
                    return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.result);
                }   else console.log(' > Ending current Step Handling : PROMPTing msg of index  ',step.index,'\n');
         

                // If a prompt is defined in the script, use dc.prompt to call it.
                // This prompt must be a valid dialog defined somewhere in your code!
                if (line.collect && line.action !== 'beginDialog') {
                    try {
                        // seems will start a begindialog ( will issue a prompt) put on top of stake returning here after received the user answare
                        // so  returning from a begindialog will call dc.endDialog that come back here in resumedialog 
                        return yield dc.prompt(this._prompt, this.makeOutgoing(line, step.values,step));
                    }
                    catch (err) {
                        console.error(err);
                        yield dc.context.sendActivity(`Failed to start prompt ${this._prompt}`);
                        return yield step.next();
                    }
                    // If there's nothing but text, send it!
                    // This could be extended to include cards and other activity attributes.
                }
                else {
                    // if there is text, attachments, or any channel data fields at all...
                    if (line.type || line.text || line.attachments || (line.channelData && Object.keys(line.channelData).length)) {
                        yield dc.context.sendActivity(this.makeOutgoing(line, step.values,step));
                    }
                    else if (!line.action) {
                        console.error('Dialog contains invalid message', line);
                    }
                    if (line.action) {
                        let res = yield this.handleAction(line, dc, step);
                        if (res !== false) {
                            return res;
                        }
                    }
                    return yield step.next();
                }
            }
            else {
                // End of script so just return to parent
                return yield this.end(dc);
            }
        });
    }
    /**
     * Run a dialog step, based on the index and thread_name passed in.
     * @param dc The current DialogContext
     * @param index The index of the current step
     * @param thread_name The name of the current thread
     * @param reason The reason given for running this step
     * @param result The result of the previous turn if any : 
     *              >>>  a string or the values of the switching thread or returning child dialog step.values ( nb: are also in state)
     */
    runStep(dc, index, thread_name, reason, result) {// if coming from gotothread or child dialog is a step.values obj
        return __awaiter(this, void 0, void 0, function* () {

            // Update the step index
            const state = dc.activeDialog.state;
            state.stepIndex = index;
            state.thread = thread_name;
            // Create step context
            const nextCalled = false;

// hotel customization 
            /* moved to conversation :
           //  when receiving text (user answere put in userTurn , that can be used in onStep usually at index 0 )
           // >>>>>  better set state.userTurn in caller  dc.xxxDialog()
           // if(Object.prototype.toString.call(myVar) === "[object String]")
            if(typeof result === 'string' || result instanceof String){
                state.userTurn=result;
            }else state.userTurn=null;
            */

            /* to move to conversation :
            let msgSent;// the
            // goon should warn that we goon to next step using a previous msg prompt , 
            // >>>>>>>>>>>>>>>>  so shoud be index-1 otherwise should be index -2 ??
            if(state.goon||state.goon>=index-1){msgSent=state.goon;// usually step run with a user answare to msg of step with index-1 
                console.log('\n runstep thread: ',thread_name,' index is ' + index ,' setgoon is set in TT when goon with no step msg : ',state.goon,' text is ',result);
            }else msgSent=state.goon;???????????
            state.goon=null;// ???
*/


            const step = {

                //msgSent,// here usually call index with user answere to previous msg 

                index: index,
                thread: thread_name,
                state: state,
                options: state.options,
                reason: reason,
                result: result,
                values: state.values,
                next: (stepResult) => __awaiter(this, void 0, void 0, function* () {
                    if (nextCalled) {
                        throw new Error(`ScriptedStepContext.next(): method already called for dialog and step '${this.id}[${index}]'.`);
                    }
                    return yield this.resumeDialog(dc, botbuilder_dialogs_1.DialogReason.nextCalled, stepResult);
                })
            };
            // did we just start a new thread?
            // if so, run the before stuff.
            if (index === 0) {

                console.log('\n ** start runStep  ');

                yield this.runBefore(step.thread, dc, step);
                // did we just change threads? if so, restart
                if (index !== step.index || thread_name !== step.thread) {
                    return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                }
            }
            // Execute step
            const res = yield this.onStep(dc, step);
            return res;
        });
    }
    /**
     * Automatically called when the the dialog ends and causes any handlers bound using `after()` to fire. Do not call this directly!
     * @ignore
     * @param dc The current DialogContext
     * @param value The final value collected by the dialog.
     */
    end(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: may have to move these around
            // shallow copy todo: may need deep copy
            const result = Object.assign({}, dc.activeDialog.state.values);
            yield dc.endDialog(result);
            yield this.runAfter(dc, result);
            return botbuilder_dialogs_1.DialogTurnStatus.complete;
        });
    }
    /**
     * Translates a line from the dialog script into an Activity. Responsible for doing token replacement.
     * @param line a message template from the script
     * @param vars an object containing key/value pairs used to do token replacement on fields in the message template
     */
    makeOutgoing(line, vars,step) {// vars=step.values
        let outgoing;
        if (line.quick_replies) {
            outgoing = botbuilder_1.MessageFactory.suggestedActions(line.quick_replies.map((reply) => { return { type: botbuilder_1.ActionTypes.PostBack, title: reply.title, text: reply.payload, displayText: reply.title, value: reply.payload }; }), line.text ? line.text[0] : '');
        }
        else {
            outgoing = botbuilder_1.MessageFactory.text(line.text ? line.text[Math.floor(Math.random() * line.text.length)] : '');
        }
        if (!outgoing.channelData) {
            outgoing.channelData = {};
        }
        // set the type
        if (line.type) {
            outgoing.type = line.type;
        }
        // copy all the values in channelData fields
        for (var key in line.channelData) {
            outgoing.channelData[key] = line.channelData[key];
        }
        let rtext=outgoing.text;
        // Handle template token replacements
        if (outgoing.text) {
            let context={ vars: vars,conf:step.values.__conf };// can be more articulated.do not pass appstatus , conf is the match the user did in last turn
            if(this.mustacheF){context.mustacheF=this.mustacheF;// add function (not saved in state)
            // overwrite by mustache !!if(this.mustacheF.out&&step){this.mustacheF.out.bind(step);}
            // so just insert step into context !
            context.step=step;
            step.curLine=line ;// pass into step the  ask name passing line . uso : ........

            // insert vars calc between &&....&&  example : template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated
            outgoing.text=looseJsonParse(outgoing.text,Object.assign({},context.vars));

//console.log(' outgoing is rendering template : ',outgoing.text)

            }
            outgoing.text = mustache.render(outgoing.text, context);//{ vars: vars });
            step.values.__conf=null;
            console.log(' text to render : ',rtext,' \n outgoing has rendered : ',outgoing.text, ' context is ', context);
        }
        // process templates in native botframework attachments
        if (line.attachments) {
            outgoing.attachments = this.parseTemplatesRecursive(line.attachments, vars);
        }
        // process templates in slack attachments
        if (outgoing.channelData.attachments) {
            outgoing.channelData.attachments = this.parseTemplatesRecursive(outgoing.channelData.attachments, vars);
        }
        // process templates in facebook attachments
        if (outgoing.channelData.attachment) {
            outgoing.channelData.attachment = this.parseTemplatesRecursive(outgoing.channelData.attachment, vars);
        }
        return outgoing;
    }
    /**
     * Responsible for doing token replacements recursively in attachments and other multi-field properties of the message.
     * @param attachments some object or array containing values for which token replacements should be made.
     * @param vars an object defining key/value pairs used for the token replacements
     */
    parseTemplatesRecursive(attachments, vars) {
        if (attachments && attachments.length) {
            for (let a = 0; a < attachments.length; a++) {
                for (let key in attachments[a]) {
                    if (typeof (attachments[a][key]) === 'string') {
                        attachments[a][key] = mustache.render(attachments[a][key], { vars: vars });
                    }
                    else {
                        attachments[a][key] = this.parseTemplatesRecursive(attachments[a][key], vars);
                    }
                }
            }
        }
        else {
            for (let x in attachments) {
                if (typeof (attachments[x]) === 'string') {
                    //let context={ vars: vars };// can be more articulated
                    //if(vars.excel.out)vars.excel.out.bound(step);
                    let context={ vars: vars };// can be more articulated
                    attachments[x] = mustache.render(attachments[x], context);
                }
                else {
                    attachments[x] = this.parseTemplatesRecursive(attachments[x], vars);
                }
            }
        }
        return attachments;
    }
    /**
     * Handle the scripted "gotothread" action - requires an additional call to runStep.
     * @param thread The name of the thread to jump to
     * @param dc The current DialogContext
     * @param step The current step object
     */
    gotoThreadAction(thread, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            step.thread = thread;
            step.index = 0;
            return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
        });
    }
    /**
     * Accepts a Botkit script action, and performs that action
     * @param path A conditional path in the form {action: 'some action', handler?: some handler function, maybe_other_fields}
     * @param dc The current DialogContext
     * @param step The current stpe object
     */
    handleAction(path, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            if (path.handler) {
                const index = step.index;
                const thread_name = step.thread;
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);
                yield path.handler.call(this, step.result, convo, bot);
                // did we just change threads? if so, restart this turn
                if (index !== step.index || thread_name !== step.thread) {
                    return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                }
                return false;
            }
            switch (path.action) {
                case 'next':
                    // noop
                    break;
                case 'complete':
                    step.values._status = 'completed';
                    return yield this.end(dc);
                case 'stop':
                    step.values._status = 'canceled';
                    return yield this.end(dc);
                case 'timeout':
                    step.values._status = 'timeout';
                    return yield this.end(dc);
                case 'execute_script':
                    const ebot = yield this._controller.spawn(dc);
                    console.log(' handleAction : execute script was requested',path);
                    var clonop=Object.assign({ thread: path.execute.thread }, step.values);
                    //072019 anyway rewrite thread
                   clonop.thread=path.execute.thread;
                    return yield ebot.replaceDialog(path.execute.script, clonop);
                case 'beginDialog':
                console.log(' handleAction : begindialog was requested  ',path);
                    let rbot = yield this._controller.spawn(dc);
                    return yield rbot.beginDialog(path.execute.script, Object.assign({ thread: path.execute.thread }, step.values));
                case 'repeat':
                    return yield this.runStep(dc, step.index - 1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled);
                case 'wait':
                    // reset the state so we're still on this step.
                    step.state.stepIndex = step.index - 1;
                    // send a waiting status
                    return { status: botbuilder_dialogs_1.DialogTurnStatus.waiting };
                default:
                    // the default behavior for unknown action in botkit is to gotothread
                    if (this.script[path.action]) {
                        console.log(' handleAction : gotoscript was requested',path);
                        return yield this.gotoThreadAction(path.action, dc, step);
                    }
                    console.warn('NOT SURE WHAT TO DO WITH THIS!!', path);
                    break;
            }
            return false;
        });
    }
}
exports.BotkitConversation = BotkitConversation;
//# sourceMappingURL=conversation.js.map

function indOf(key,matr,col){
    let ism=false,it;
    if(matr&&key)
for(it=0;it<matr.length;it++){
        if(matr[it][col]==key){ ism=true;break;}
    }
    if(ism)return it;else return -1;
}

function looseJsonParse(templ,vars){//extract in cond string a vars . format  xxxx&&vars.excel.....&&yyyy
    // see evalmozilla.js, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
    // call  ftempl=looseJsonParse(template,Object.assign({},context.vars,{aa}));
    // template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated

        // usually used in case we want to generate same text without use a onchange 
        // or also when in a msg we want to use a {{}} a context var depending from past status  
        // or in a condition we want to test not the user speech but the passed var got 

     let ioa = templ.indexOf('&&'),fcorpus,fc;
      let templP=templ.split('&&');

       //      console.log('looseJsonParse : templP is :',templP);
     //if (ioa > 0){let ioa1 = templ.indexOf('&&',ioa+3);
      //  if(ioa1>0)fcorpus = templ.substring(ioa+2, ioa1);}

      // max 2 substitution 
      let ret,calc;

      if(templP.length==3||templP.length==5){
      // evaluate fcorpus in context 
        fc=templP[1];
        console.log('looseJsonParse : fc is :',fc);
        let myf='"use strict";' + fc;
        // calc=Function(myf)();
        //calc=Function('"use strict";' + fc)();
         //calc=Function( fc).call(vars);
        //calc=Function( fc).call(vars);
        calc=eval( fc);
        // OK calc=eval(myf);
        //   console.log('looseJsonParse  calc :',calc);
        if(calc)ret=templP[0].concat(calc).concat(templP[2]);else ret=templP[0].concat(templP[2]);
      }else return templ;
      if(templP.length==5){
        // evaluate fcorpus in context 
          fc=templP[3];
          console.log('looseJsonParse : fc is :',fc);
          let myf='"use strict";' + fc;
          // calc=Function(myf)();
          //calc=Function('"use strict";' + fc)();
           //calc=Function( fc).call(vars);
          //calc=Function( fc).call(vars);
          calc=eval( fc);
          // OK calc=eval(myf);
          //   console.log('looseJsonParse  calc :',calc);
          if(calc!=null)ret=ret.concat(calc).concat(templP[4]);else ret=ret.concat(templP[4]);
        }else return ret;

      if(ret){
          console.log(' && case transformer text is ret= ',ret);return ret;}else return templ;
                                          
     // return Function('"use strict";return (' + obj + ')')();
    }
