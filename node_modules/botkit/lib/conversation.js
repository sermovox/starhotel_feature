// Copyright luigi marson, Inc. and other Node contributors. some reference from microsoft  botbuilder: see that package copyright.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

"use strict";
const querystring=require('querystring'),
AhoCorasick = require('ahocorasick');// npm install ahocorasick
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dialogWrapper_1 = require("./dialogWrapper");
const botbuilder_1 = require("botbuilder");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const mustache = require("mustache");
const debug = require('debug')('botkit:conversation');
// pistola 
let logsout;// wrk log var used to build logs strings to log with console,console_ or logs (winston)

let consorig=console.error;

// better reset lv,,, fron .env !!!
const lv=6,// normal console level , console will be disacitveded in production 
lv_=6,// console_ level , it wont be deactivated on production with a editing comment utility
loglv=5;// entry like : if(loglv>3)logs(logsout) >>> will use a debugprinting function set il 
let logs=console.log,// the log into logger , production logger tracking conversations . RESET in this constructor : logs=this._vcontroller.vFw.winston.info;
 elogs=console.error,// RESET in this constructor :  elogs=this._vcontroller.vFw.winston.error;
 // nb console.error will be RESET to : console.error=function(...args){consorig(...args);elogs(...args)}
 winston,
 //console.log=function(){},// global console ?. canbe overwritten in constructor
console_={log:// console_   in production change all:   console.log( > if(false)console.log(..); eventually delete all console.log and comments . then only console_.log can write to console !
function (frst,...args){// use : console_.log(a,b,c) or  console_.log(2,a,b,c). will call elogs or logs
   // function (frst,txt){
       let clog=logs,//=console.log
       elog=elogs;//=console.error
    
    if(Number.isInteger(frst)){
        if(lv_<frst)return;

    //}else{
        args.unshift(frst);
        if(frst<3)elog(args);
        else  clog(...args,{class:'conversation'});// clog(args);
    }else{
    
       clog(first,...args);///   console.log(args);
     }



}};

// conclusione after resetting :
//  nb winston : see in onchange.js   and './helpers/logs'
// elogs(a,b,c) >  winston.error(a,b,c)   
// logs(a,b,c) >  winston.info(a,b,c)
// console.error > orig console.error +  winston.error
// console_.log(3,a,b,c)  >  winston.error(a,b,c) or  winston.info(a,b,c) , depending from 3
//  console_.log(a,b,c)  >    winston.info(a,b,c)
//  so we can leave ( using minimify):
//      console.log , rimane console_.log e logs
//      and optionally 
//      console.error, rimane console_.log(1,,,,) e elogs 

/**
 * An extension on the [BotBuilder Dialog Class](https://docs.microsoft.com/en-us/javascript/api/botbuilder-dialogs/dialog?view=botbuilder-ts-latest) that provides a Botkit-friendly interface for
 * defining and interacting with multi-message dialogs. Dialogs can be constructed using `say()`, `ask()` and other helper methods.
 *
 * ```javascript
 * // define the structure of your dialog...
 * const convo = new BotkitConversation('foo', controller);
 * convo.say('Hello!');
 * convo.ask('What is your name?', async(answer, convo, bot) => {
 *      await bot.say('Your name is ' + answer);
 * });
 * controller.dialogSet.add(convo);
 *
 * // later on, trigger this dialog by its id
 * controller.on('event', async(bot, message) => {
 *  await bot.beginDialog('foo');
 * })
 * ```
 */


 // CODING DEBUG OPTIONS (put in a branch ????):

 const goOnWOColl=true,goOnWOColl2=true;//news 052021 goon routing code version : goon also if miss ask collection. la catena dei goon non viene interrotta da ask con template senza collection ne da returning from child











class BotkitConversation extends botbuilder_dialogs_1.Dialog {
    /**
     * Create a new BotkitConversation object
     * @param dialogId A unique identifier for this dialog, used to later trigger this dialog
     * @param controller A pointer to the main Botkit controller
     */
    constructor(dialogId, controller) {
        super(dialogId);// .. and surely set this.id=dialogId
        console.log(' botkitconvo requested id ',dialogId);


        this._beforeHooks = {};
        this._afterHooks = [];
        this._changeHooks = {};
        this._changeHooksA = {};// after conditions run
        this.script = {};
        this._controller = controller;

        // se copyright :luigi added let vctl=require('./nat/onChange.js')controller.addPluginExtension('vCtl', vctl);
        this._vcontroller=controller.plugins.vCtl;
        if(this._vcontroller){this.mustacheF=this._vcontroller.mustacheF;// store singleton for mustache function (  cant be set in status (/vars/values) as it wont store/persist functions )
           logs=this._vcontroller.vFw.winston.info;// or .logs;
           elogs=this._vcontroller.vFw.winston.error;// or .logs;
           //console.log=logs.info;// substitute. question : so global scope ?? . no works: circular reference !
           // console.error=logs.error;
           console.error=function(...args){consorig(...args);// ridefinendo console.error mi perdo la riga che spara l'errore !!
            elogs(...args)};
           // winston to use
           winston=this._vcontroller.vFw.winston;// see  vFw.winston== require('./helpers/logs').logger(env); 
                                                   // use :           winston.info('text',{pgm:'conversation'});
        }
            // DIRECTIVE status under control of loop directive algo
            // TODO basic loop control : count/repeat= loop cont repetition,see runstep() ,condDefInd : the condition to match if maxrep is got , maxnmp : max number of model to put in notmatchedprompt ( see out..miss)
        this.dir={asks:{model:{}},count:0,condDefInd:-1,condDefNam:null,maxrep:10,maxnmp:3};// .cond added after to add condition directives got from  macro area.  count used in runstep(),condDefInd used in ask onStep()
                    // nb directives values are get also in ask using custom field started with dir-


        // Make sure there is a prompt we can use.
        // TODO: maybe this ends up being managed by Botkit
        this._prompt = this.id + '_default_prompt';
        this._controller.dialogSet.add(new botbuilder_dialogs_1.TextPrompt(this._prompt));
        return this;
    }
    /**
     * Add a non-interactive message to the default thread.
     * Messages added with `say()` and `addMessage()` will _not_ wait for a response, will be sent one after another without a pause.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     *
     * ```javascript
     * let conversation = new BotkitConversation('welcome', controller);
     * conversation.say('Hello! Welcome to my app.');
     * conversation.say('Let us get started...');
     * ```
     *
     * @param message Message template to be sent
     */
    say(message) {
        this.addMessage(message, 'default');
        return this;
    }
    /**
     * An an action to the conversation timeline. This can be used to go to switch threads or end the dialog.
     *
     * When provided the name of another thread in the conversation, this will cause the bot to go immediately
     * to that thread.
     *
     * Otherwise, use one of the following keywords:
     * * `stop`
     * * `repeat`
     * * `complete`
     * * `timeout`
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     *
     * ```javascript
     *
     * // go to a thread called "next_thread"
     * convo.addAction('next_thread');
     *
     * // end the conversation and mark as successful
     * convo.addAction('complete');
     * ```
     * @param action An action or thread name
     * @param thread_name The name of the thread to which this action is added.  Defaults to `default`
     */
    addAction(action, thread_name = 'default') {
        this.addMessage({ action: action }, thread_name);
        return this;
    }
    /**
     * Cause the dialog to call a child dialog, wait for it to complete,
     * then store the results in a variable and resume the parent dialog.
     * Use this to [combine multiple dialogs into bigger interactions.](../conversations.md#composing-dialogs)
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * // define a profile collection dialog
     * let profileDialog = new BotkitConversation('PROFILE_DIALOG', controller);
     * profileDialog.ask('What is your name?', async(res, convo, bot) => {}, {key: 'name'});
     * profileDialog.ask('What is your age?', async(res, convo, bot) => {}, {key: 'age'});
     * profileDialog.ask('What is your location?', async(res, convo, bot) => {}, {key: 'location'});
     * controller.addDialog(profileDialog);
     *
     * let onboard = new BotkitConversation('ONBOARDING', controller);
     * onboard.say('Hello! It is time to collect your profile data.');
     * onboard.addChildDialog('PROFILE_DIALOG', 'profile');
     * onboard.say('Hello, {{vars.profile.name}}! Onboarding is complete.');
     * ```
     *
     * @param dialog_id the id of another dialog
     * @param key_name the variable name in which to store the results of the child dialog. if not provided, defaults to dialog_id.
     * @param thread_name the name of a thread to which this call should be added. defaults to 'default'
     */
    // luis 092020 here addQuestion adds a ask with a condition that will have action beginDialog  and a execute specification
    addChildDialog(dialog_id, key_name, thread_name = 'default') {
        this.addQuestion({
            action: 'beginDialog',
            execute: {
                script: dialog_id
            }
        }, [], { key: key_name || dialog_id }, thread_name);
        return this;
    }
    /**
     * Cause the current dialog to handoff to another dialog.
     * The parent dialog will not resume when the child dialog completes. However, the afterDialog event will not fire for the parent dialog until all child dialogs complete.
     * Use this to [combine multiple dialogs into bigger interactions.](../conversations.md#composing-dialogs)
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * let parent = new BotkitConversation('parent', controller);
     * let child = new BotkitConversation('child', controller);
     * parent.say('Moving on....');
     * parent.addGotoDialog('child');
     * ```
     *
     * @param dialog_id the id of another dialog
     * @param thread_name the name of a thread to which this call should be added. defaults to 'default'
     */
    addGotoDialog(dialog_id, thread_name = 'default') {
        this.addMessage({
            action: 'execute_script',
            execute: {
                script: dialog_id
            }
        }, thread_name);
        return this;
    }
    /**
     * Add a message template to a specific thread.
     * Messages added with `say()` and `addMessage()` will be sent one after another without a pause.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * let conversation = new BotkitConversation('welcome', controller);
     * conversation.say('Hello! Welcome to my app.');
     * conversation.say('Let us get started...');
     * // pass in a message with an action that will cause gotoThread to be called...
     * conversation.addAction('continuation');
     *
     * conversation.addMessage('This is a different thread completely', 'continuation');
     * ```
     *
     * @param message Message template to be sent
     * @param thread_name Name of thread to which message will be added
     */
    addMessage(message, thread_name) {
        if (!thread_name) {
            thread_name = 'default';
        }
        if (!this.script[thread_name]) {
            this.script[thread_name] = [];
        }
        if (typeof (message) === 'string') {
            message = { text: [message] };
        }
        this.script[thread_name].push(message);
        return this;
    }
    /**
     * Add a question to the default thread.
     * In addition to a message template, receives either a single handler function to call when an answer is provided,
     * or an array of handlers paired with trigger patterns. When providing multiple conditions to test, developers may also provide a
     * handler marked as the default choice.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * ```javascript
     * // ask a question, handle the response with a function
     * convo.ask('What is your name?', async(response, convo, bot) => {
     *  await bot.say('Oh your name is ' + response);
     * }, {key: 'name'});
     *
     * // ask a question, evaluate answer, take conditional action based on response
     * convo.ask('Do you want to eat a taco?', [
     *  {
     *      pattern: 'yes',
     *      type: 'string',
     *      handler: async(response, convo, bot) => {
     *          return await convo.gotoThread('yes_taco');
     *      }
     *  },
     *  {
     *      pattern: 'no',
     *      type: 'string',
     *      handler: async(response, convo, bot) => {
     *          return await convo.gotoThread('no_taco');
     *      }
     *   },s
     *   {
     *       default: true,
     *       handler: async(response, convo, bot) => {
     *           await bot.say('I do not understand your response!');
     *           // start over!
     *           return await convo.repeat();
     *       }
     *   }
     * ], {key: 'tacos'});
     * ```
     *
     * @param message a message that will be used as the prompt
     * @param handlers one or more handler functions defining possible conditional actions based on the response to the question.
     * @param key name of variable to store response in.
     */
    ask(message, handlers, key) {
        this.addQuestion(message, handlers, key, 'default');
        return this;
    }
    /**
     * Identical to [ask()](#ask), but accepts the name of a thread to which the question is added.
     *
     * [Learn more about building conversations &rarr;](../conversations.md#build-a-conversation)
     * @param message A message that will be used as the prompt
     * @param handlers One or more handler functions defining possible conditional actions based on the response to the question
     * @param key Name of variable to store response in.
     * @param thread_name Name of thread to which message will be added
     */
    addQuestion(message, handlers, key, thread_name) {// ask  handlers = condition matcher  if stringthe handler is the def regex 
        if (!thread_name) {
            thread_name = 'default';
        }
        if (!this.script[thread_name]) {
            this.script[thread_name] = [];
        }
        if (typeof (message) === 'string') {
            message = { text: [message] };
        }
        message.collect = {
            key: typeof (key) === 'string' ? key : key.key
        };
        if (Array.isArray(handlers)) {
            message.collect.options = handlers;
        }
        else if (typeof (handlers) === 'function') {
            message.collect.options = [
                {
                    default: true,
                    handler: handlers
                }
            ];
        }
        // ensure all options have a type field
        message.collect.options.forEach((o) => { if (!o.type) {
            o.type = 'string';
        } });
        this.script[thread_name].push(message);
        return this;
    }
    /**
     * Register a handler function that will fire before a given thread begins.
     * Use this hook to set variables, call APIs, or change the flow of the conversation using `convo.gotoThread`
     *
     * ```javascript
     * convo.addMessage('This is the foo thread: var == {{vars.foo}}', 'foo');
     * convo.before('foo', async(convo, bot) => {
     *  // set a variable here that can be used in the message template
     *  convo.setVar('foo','THIS IS FOO');
     *
     * });
     * ```
     *
     * @param thread_name A valid thread defined in this conversation
     * @param handler A handler function in the form async(convo, bot) => { ... }
     */
    before(thread_name, handler) {
        if (!this._beforeHooks[thread_name]) {
            this._beforeHooks[thread_name] = [];
        }
        this._beforeHooks[thread_name].push(handler);
    }
    /**
     * This private method is called before a thread begins, and causes any bound handler functions to be executed.
     * @param thread_name the thread about to begin
     * @param dc the current DialogContext
     * @param step the current step object
     */
    runBefore(thread_name, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(' Before:', this.id, thread_name);
           console.log('starting Before :', this.id, thread_name);
            if (this._beforeHooks[thread_name]) {
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);

                // luigi 052020
                convo.openStep=step;// needs ??,  to set a app wrapper
                
                // to pass script into handler
                convo.script=this.script;

                for (let h = 0; h < this._beforeHooks[thread_name].length; h++) {
                    let handler = this._beforeHooks[thread_name][h];
                    yield handler.call(this, convo, bot);
                }
                // store TEMPORARELY in mustacheF the function loaded in values.mustacheF
                //this.mustacheF=this.mustacheF||step.mustacheF;
               // this.mustacheF=this.mustacheF||this._controller.plugins.vCtl.mustacheF;
            }
        });
    }
    /**
     * Bind a function to run after the dialog has completed.
     * The first parameter to the handler will include a hash of all variables set and values collected from the user during the conversation.
     * The second parameter to the handler is a BotWorker object that can be used to start new dialogs or take other actions.
     *
     * [Learn more about handling end of conversation](../conversations.md#handling-end-of-conversation)
     * ```javascript
     * let convo = new BotkitConversation(MY_CONVO, controller);
     * convo.ask('What is your name?', [], 'name');
     * convo.ask('What is your age?', [], 'age');
     * convo.ask('What is your favorite color?', [], 'color');
     * convo.after(async(results, bot) => {
     *
     *      // handle results.name, results.age, results.color
     *
     * });
     * controller.addDialog(convo);
     * ```
     *
     * @param handler in the form async(results, bot) { ... }
     */
    after(handler) {
        this._afterHooks.push(handler);
    }
    /**
     * This private method is called at the end of the conversation, and causes any bound handler functions to be executed.
     * @param context the current dialog context
     * @param results an object containing the final results of the dialog
     */
    runAfter(context, results) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('After:', this.id);
            if (this._afterHooks.length) {
                const bot = yield this._controller.spawn(context);
                for (let h = 0; h < this._afterHooks.length; h++) {
                    let handler = this._afterHooks[h];
                    yield handler.call(this, results, bot);
                }
            }
        });
    }


        /**
     * Bind a function to run whenever a user answers a specific question.  Can be used to validate input and take conditional actions.
     *
     * ```javascript
     * convo.ask('What is your name?', [], 'name');
     * convo.onChange('name', async(response, convo, bot) {
     *
     *  // user changed their name!
     *  // do something...
     * });
     * 
     * 
     * for a onchange we used a indirect strategy :
     *      in fwbase  we registerd a normal cms onchage ( cms recovers the right convo and register the cb )
     *          that handler was in space of fwspace and calls a cb from the user directive in which it was injected just before        
     *              the injected handler 
     * 
     * 
     * ```
     * @param variable name of the variable to watch for changes
     * @param handler a handler function that will fire whenever a user's response is used to change the value of the watched variable
     */
    /*
    registerFwServiceCb(eventService,variable, handler) {//  fwCb={fWService1:null,askS:{dynMatch},thS:{}};
        if (!this._changeHooks[variable]) {
            this._changeHooks[variable] = [];
        }
        this._changeHooks[variable].push(handler);
    }
    */


    /**
     * Bind a function to run whenever a user answers a specific question.  Can be used to validate input and take conditional actions.
     *
     * ```javascript
     * convo.ask('What is your name?', [], 'name');
     * convo.onChange('name', async(response, convo, bot) {
     *
     *  // user changed their name!
     *  // do something...
     * });
     * 
     * 
     * ```
     * @param variable name of the variable to watch for changes
     * @param handler a handler function that will fire whenever a user's response is used to change the value of the watched variable
     */
    onChange(variable, handler) {
        if (!this._changeHooks[variable]) {
            this._changeHooks[variable] = [];
        }
        this._changeHooks[variable].push(handler);
    }
    onChangeAfterCond(variable, handler) {
        if (!this._changeHooksA[variable]) {
            this._changeHooksA[variable] = [];
        }
        this._changeHooksA[variable].push(handler);
    }
    /**
     * This private method is responsible for firing any bound onChange handlers when a variable changes
     * @param variable the name of the variable that is changing
     * @param value the new value of the variable
     * @param dc the current DialogContext
     * @param step the current step object
     */
    runOnChange(variable, value, dc, step) {

        // trick : if variable is null , means 

        return __awaiter(this, void 0, void 0, function* () {
            debug('OnChange:', this.id, variable);
            console.log(' convo/cmd ', this.id,'  trying to fire registered  OnChange on ask ', variable);// id is the convo id/name ( cmd) 
            if (this._changeHooks[variable] && this._changeHooks[variable].length) {
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);

                // luigi 052020
                convo.openStep=step;// needs ??,  to set a app wrapper

                for (let h = 0; h < this._changeHooks[variable].length; h++) {
                    let handler = this._changeHooks[variable][h];
                    // await handler.call(this, value, convo);
                    yield handler.call(this, value, convo, bot);
                }
            }


        });
    }
    runOnChangeA(variable, value, dc, step) {

        // trick : if variable is null , means 

        return __awaiter(this, void 0, void 0, function* () {
            debug('OnChange:', this.id, variable);
            console.log('OnChange:', this.id, variable);
            if (this._changeHooksA[variable] && this._changeHooksA[variable].length) {
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);

                // luigi 052020
                convo.openStep=step;// needs ??,  to set a app wrapper

                for (let h = 0; h < this._changeHooksA[variable].length; h++) {
                    let handler = this._changeHooksA[variable][h];
                    // await handler.call(this, value, convo);
                    yield handler.call(this, value, convo, bot);
                }
            }


        });
    }
    /**
     * Called automatically when a dialog begins. Do not call this directly!
     * @ignore
     * @param dc the current DialogContext
     * @param options an object containing initialization parameters passed to the dialog. may include `thread` which will cause the dialog to begin with that thread instead of the `default` thread.
     */
    beginDialog(dc, options) {// start the dialog setting the TURN result :is the TURN user text that is the asnwere to bot prompt that triggered this dialog
        // nb se e un child le option sono le vars= step.values del father ma se arrivo qui da un dc.replacedialod allora non ho un father 
        // qundi non volendome mescolate (YYHH) col nuove values del child , sopratutto qulle che si rif allo stato dei ASS :
        //      ASS : le vars.excel direc dir session ... verranno sostituite nel nuovo dialog ma le precedenti le trovo nel ctxVars
        //      e anche nel caso di  dc.replacedialog 
        //  allora gli aggiungo uno stack :ctxVars=[{convoid,level1vars},,,] e il nome del chiamanti
        // le vars.excel direc dir session ... verranno sostituite nel nuovo dialog ma le precedenti le trovo nel ctxVars

// dubbio finale : ma non è che conviene mescolare il tutto come si fa per le vars normali , cosi le variabili di stato dei model (matchers,,) mi seguono durante e varie convo ????
//           in altre parole , non mi conviene inizializzare le var fw ASS al solo begin del primo thred e poi laciare che vengano passate automaticamente da convo a convo ??
// il problema e' che dovrei caricare tuttie le dichiarazioni dei convo in model.js !!!!!!!
// quindi idea : aggiungi in modo incrementale le nuove var al primo begin del thread def in fw base !!!
//          see fwbase.initCmd.controller.plugins.cms.before()

        return __awaiter(this, void 0, void 0, function* () {
            // Initialize the state:
            // - attach options, init dir as this.dir , clone options to values
            const state = dc.activeDialog.state;// if called by dc.beginDialog() state is void as the new dialog is just put onto the top of stack
            state.options = options || {};

            state.dir=state.dir||this.dir;// Error we can father dir in options.session.dir (session to be reassigned in th.begin()) to clone in child ?? , init( x count replay ?)

            // so original options are stored separated from cloned values=vars  !! ( deep or shallow cloning ???)
            state.values = Object.assign({}, options);// so child will take session,matches and askmatches of father, but after they will diverge ?? , see fwbase .begin
            let result,th= state.options.thread || 'default';
            // Run the first step
            console.log('\n *** beginDialog start for cmd ',dc.activeDialog.id,' , calling runStep , if  default thread assign user text in results, user text:',dc.context.activity.text,
            '\n IS A CHILD if options are CLONED/injected on state.values=vars , options: ',options,' anyway if th is default we insert the past user text on result'
            );
            if(th=='default')result=dc.context.activity.text;// set the TURN result :is the TURN user text that is the asnwere to previous bot prompt
           // console.log(' ùùùùùùùùùùùùùùùùùùùù  beginDialog called , id is ' ,dc.activeDialog.id,' state is ',state,' app is : ',state.app);
            //return yield this.runStep(dc, 0,th, botbuilder_dialogs_1.DialogReason.beginCalled);         
            let ret= yield this.runStep(dc, 0,th, botbuilder_dialogs_1.DialogReason.beginCalled,result);
           // console.log(' ùùùùùùùùùùùùùùùùùùùù  beginDialog returned , id is ',dc.activeDialog.id,' state is ',state,' app is : ',state.app);
            return ret;
        });
    }
    /**
     * Called automatically when an already active dialog is continued. Do not call this directly!
     * @ignore
     * @param dc the current DialogContext
     */
    continueDialog(dc) {// continue the dialog setting the TURN result :is the TURN user text that is the asnwere to previous bot prompt from this dialog
                        // si risolve quando risolvo resumeDialog (quindi il adapter invia la risposta ) 
                        // quindi un runstep che lncia un step con solo say chaina un runstep seguente e se ha solo un say la catena si ripete fino che non trovo un ask ? 
        return __awaiter(this, void 0, void 0, function* () {
                        /*
            start context interrupting code 
                at this level we can inject the interrupt managed at handleturn by context manager :
                ctx mng have current context set in goto/exec :
                    - coding the start thred : default-thenextContext or ,better :
                    - just fill some activity.raw field the next contexts list  to add as out-context and the remove/reset  out-context list
                 so the ctx will updates  that current valid context on cur-cont list ( some old context can also be discarded) because the running convo have filled all data and is ready/wants to do some cmd/service in that context
                a cmd can declare its context by append _incontext it to ots name 
                the ctx manager at handle turn will search trigger for current turn on trying the trigger of all cmd that are on the cur context list and do a begin dialog on this cmd 
                when the cmd will ends previous cmd will be resumed but as it was interrupted by ctx manager , how?, the resumed dialog coming in this function will see in context.activity.type='ctx_resumed'
                so can fire on current ask a interrupt condition that 
                    - if a child returns the child return adding .complete='ctx-inter' that will be managed by father, as sys triggered ...., in the ctx loop ask of current major intent th loop   


            */


            // Don't do anything for non-message activities
            if (dc.context.activity.type !== botbuilder_1.ActivityTypes.Message) {
                return botbuilder_dialogs_1.Dialog.EndOfTurn;
            }
            // Run next step with the message text as the result.

            console.log('*** continueDialog called' );

            return yield this.resumeDialog(dc, botbuilder_dialogs_1.DialogReason.continueCalled, dc.context.activity.text);
        });
    }
    /**
     * Called automatically when a dialog moves forward a step. Do not call this directly!
     * @ignore
     * @param dc The current DialogContext
     * @param reason Reason for resuming the dialog
     * @param result Result of previous step
     */
    resumeDialog(dc, reason, result) {// rersult is the child values/vars in case we are ruturning from child, or can be the user text in case of continuing the convo with a new turn
        // usually when a prompt dialog ends will resume its father (this convo) on stack !
        // or a this.continueDialog can also call here to continue a waiting dialog
        return __awaiter(this, void 0, void 0, function* () {
            // Increment step index and run step

            // >>>> RECOVER state from dc.activeDialog.state that can be different from last step ?? 
            // ERROR  result can come from a child completed returning in end()  seting result = Object.assign({}, (childdialog=dc.activeDialog).state.values);
            //  but this father dialog has different vars in state = dc.activeDialog.state;  , 
            // 2 facts to clarify about the difference of vars properties between father and child  : 
            //                      - vars properties are different because child vars is a clone 
            //                           > but we can find some child vars into father ? 
            //                              that could happen if at beginDialog the object.assign will just copy the matchers obj reference  from  father value to child values !
            //                      - and because its a old status saved )
            const state = dc.activeDialog.state;
            console.log(' resumeDialog called state is ',state,' probably continuing a waiting convo OR returning from a child :',!((!result)||typeof (result) === 'string'));// father matches can contains child properties ???? check it with a breakpoint

// IDeA: manage a incontext to close ordinately a interrupted dialog
// try to manage many incontext strictly tied (the interrupt of a dialog because the user is been transferred ))
// so 
//  the main context and 
//  the interruption context that can smootly interrupt the on going main context
//  and to simplify we can assume the params of all context is the same : vars......
// and that 
// - the main context is the waiting ask (thread x, index y )
// - the other in context  is 'interrupt' and that the intents/events registered is just in the thread 'interrupt'. usually progammatically the event handler can be 
//    just the runBefore of the interrupt thread or 
//    just the onchange of first  ask in thread.
// to test this context just check the thread match with a trigger against  result or the the event interrupt set in activity.original.event='interrupt'  
// something like this.runStep   >  if(this.runBefore(step.thread='interrupt, dc, step)) runStep(index=0,thread='interrupt') ......
// who set event='interrupt ?   probably the interrupt  trigger (load by cms (name start with Int_....)) or te event 'interrupt)
// >>>>  better  just intercept a interrupt context in interrupts intents then recover the tc status from ds but instead of goon the current th  begin a dialog starting interrupt th that will have access to 
//              current vars filling by interrupted th  




            // luis: manage the count on previous step:
            if(state.dir.repeat_)state.dir.repeat_++;// a continuedialog is starting a step whose previous  that was asked to repeate 

          //  console.log(' ùùùùùùùùùùùùùùùùùùùù  resumeDialog called , id is ',dc.activeDialog.id,' state is ',state,' app is : ',state.app);
            let ret=yield this.runStep(dc, state.stepIndex + 1, state.thread || 'default', reason, result);
          //  console.log(' ùùùùùùùùùùùùùùùùùùùù  resumeDialog returned, id is ',dc.activeDialog.id,' state is ',state,' app is : ',state.app);
            return ret;
        });
    }
    /**
     * Called automatically to process the turn, interpret the script, and take any necessary actions based on that script. Do not call this directly!
     * @ignore
     * @param dc The current dialog context
     * @param step The current step object
     */
    onStep(dc, step) {
         return __awaiter(this, void 0, void 0, function* () {


          //  return __awaiter(this, void 0, void 0,pippo);pippo= async function* () {


            // Let's interpret the current line of the script.
            const thread = this.script[step.thread];
            // Capture the previous step value if there previous line included a prompt
            var previous = (step.index >= 1) ? thread[step.index - 1] : null;



/* WARNING   prevous is a script line/ask 

so previous.channelData if the custom fields . 
>>>>  IS NOT the message/activity activity.channelData that will be generated in makeOutgoing() as outgoing.channelData ,
            but outgoing.channelData will get all existing field of previous.channelData


    outgoing.channelData  will be sent to user later with :
    dc.prompt(this._prompt, this.makeOutgoing(line, step.values,step,dc));// send the prompt to customer via a prompt dialog that will receive the user answer and the pas to this convo)
            or
    dc.context.sendActivity(this.makeOutgoing(line, step.values,step,dc));

*/




            let addMatcRes_=this._vcontroller.vfwF.addMatcRes;// run helper ti staff

            /* 
            meanings :
            recLTurn : say that 
                    -the result is text 
                        OR IF index is 0 ( coming from a gotothread ) 
                    -  
            state.goon : state that says to next step what step the result text is referring to 

            msgSent is the index of ask whose msg template the result (user text answere) refears :
                    msgSent=state.goon < index-1 m is coming from a goon in the same thread
                    msgSent=state.goon =index -1 , nornal : is coming from normal previous step msg 
                              ( if previous step is -1 comes from begindialog and it used only in OnBefore) (sure ?)
                    msgSent=-777 , result is not text 
            userTurn contains user text that can be used in following steps (the next step.result) 
            
            cases on step.result :
                - null : when coming from   begindialog (?), replay
                             normal repeat will have a no result with no goon so no msgSent will be set so current handler will emit msg prompt
                             special repeat UU will have too a no result with also a no  goon 
                             begin dialog will have too a no result with also a no  goon 

                - string:                   runStep, continuedialog, is user answer
                - obj=step.values               gotothread (will use goon to recover userturn) , resumedialog ( return from child,)


                so  
                if null msgSent= null
                if string :
                    - set msgSent=step.index-2 : the step before the previous step 
                    - userTurn=step.result
                    if find state.goon :
                        - msgSent=state.goon

                if obj 
                    
                    if((recLTurn||step.index>0)&&(!step.msgSent) // use results in next step if exists (step.msgSent not null ) or 
                                                                 //     if index=0 recLTurn
                            step.state.goon=step.msgSent; 
                            runStep(dc, step.index+1,,,,)  >>>  will call onstep with string=result

                NB  A case  : if condition dont match with msgSent = step before the analizing condition step >>>>>  send a reply request
                                    if msgSend<index-1
            */
            /* Management SUMMARY review 15032020 use before comment than we try just try explain better 
                cases on step.result :

                const recLTurn : true if  in step 0 we got a user answer and put in text result. can be because :
                    - result is text OR
                    - the answer is recovered (from step.state.userTurn , result is received as  obj!) and put in  result recoverED from previous STEP THAT CAME TO THIS THREAD FROM  GOTOTHREAd or ....

                const goonDir flag : say to apply mixinitiative tech :
                                 if, in a ask , - not def conditions are matched ( continue or gototread ) 
                                                - ?? def action do the same only if is continue or .....    
                                                        >>> we use the current text to test the next ask conditions ( instead of respone to its template)


                - null : when coming from   startdialog, or a condition replay action 
                             normal repeat will have a no result with no goon, so no msgSent will be set,  so current step handler will emit msg prompt
                             special repeat UU will have too a no result with also a no  goon 
                             startdialog will have too a no result with also a no  goon 
                                >> question can be null with a goon ??? probably not 

                - string:           can came from :  runStep, continuedialog,begindialog(if is default thread ?)
                                    - if came with a goon from a previous step (>=0 , same thread, using runStep(index+1,,result)) state.goon is the goon step index 
                                        > so set msgSent will qualify if result is text ( the user answer ) and what step contain the msg to which the result is the answer :
                                        msgSent=state.goon < index-1 m is coming from a goon in the same thread
                                        msgSent=state.goon =index -1 , nornal : is coming from normal previous step msg 
                                                                        ( if previous step is -1 comes from begindialog and it used only in OnBefore) (sure ?)
                                        msgSent=-777 , result is not text , is obj
                                        msgSent =-1000 result is null

                                    - if come from begindialog (step 0) : todo :
                                        verify that the result is processed only in begin dialog , 
                                        who set the result ? ................ ( std bb or we set it  ?? ) and 
                                        what is result ? ......................... 


                - obj=step.values    can come from :  gotothread (will use goon to recover userturn) , return from child, 
                                                       resumedialog ( will copy its value into result , usually after a child ends  or GotoDialog
                                                        so here we insert that in a values.what specified on addChildDialog , usually the dialog_id of child)


            so  > if null msgSent= null or -1000 ?
                > if string :

                    - set msgSent=step.index-2 : the step before the previous step , WHY ???
                    - userTurn=step.result , the user text to test 
                    if find state.goon :
                        - msgSent=state.goon , the index to which the text is referring 

                    in step 0 prepare for goon possibility :
                            recLTurn=true;
                            step.msgSent=-1;, means that the msg trefears to a ask in the coming thread ( the ask fired a goto thread)


                > if obj  , (so gotothread or returning from a child ( replacedialog too ???)
                    in on step 0 , we skip previous handling and do only the current step handling  :
                    if we find in status a not null previous answer (step.state.userTurn) :
                        - set result =step.state.userTurn + set the flag recLTurn=true 
                        - step.msgSent=-1;   // mark that result as the last user answere ( we need  if we'll use goon )
       
                        - prepare for goon possibility :
                            recLTurn=true;
                            step.msgSent=-1;

                    nb  userTurn can be nulled by onchange or if goon is set false in ...direc[thread_name].loopDir.goon
                        todo , now we cant know if state.userTurn is too old and need to be discarded 


                * in current step  handler we goon if :
                    if(goonDir&&(recLTurn||step.index>0)&&(step.msgSent >-2)){// use results in next step if exists (step.msgSent not null, better > -2 ) or 
                                                            // if index=0 recLTurn will decide to goon or not

                             // TT  
                             goon code ...


                       step.state.goon=step.msgSent;  
                    return yield this.runStep(dc, step.index+1, ... // goon 
                }   else 
                    console.log(' > Ending current Step Handling : PROMPTing msg of index  ',step.index,'\n');
                    .....  // usual code to send current step message 

                ?? NB  A case  : if condition dont match with msgSent = step before the analizing condition step >>>>>  send a reply request
                                    if msgSend<index-1
            */

            // if this is index 0 try to process the userturn coming from previous thread 

           // console.log('\n\n ********************************** ONSTEP STARTING  at  index: ',step.index,'  thread : ',step.thread),' appwrapper : ',step.values.app;



           // **************   TODO :                >>>> PERFORMANCE ENHANCE substitute     is_prevCollKey=previous.collect.key; and in log : ',prevName,'



            let is_prevCollKey=null,prevName='',is_prevColl_Opt=null;// conditions
             if (previous && previous.collect && previous.collect.key) {

                ////// WARNING   is_prevCollKey = ' ' +  prevName    ?????????????????

                 is_prevCollKey = previous.collect.key;
                 prevName = ' ' + previous.collect.key;
                 
                  if (previous.collect.options) is_prevColl_Opt = previous.collect.options;// must be a key !
             }
            /* put after 
            if(typeof step.result === 'string'){
             console.log('\n\n ***** ONSTEP STARTING  at  index: ',step.index,'  thread : ',step.thread,' cmd : ',dc.activeDialog.id,', text result ',step.result,', coming from previous step/begibDialog :',step.result);
                if(is_prevCollKey)console.log('   and as in previous there are a key ',is_prevCollKey,' registered onchange will be fired on text result '); 
                if(is_prevColl_Opt)console.log('   and registered conditions  conditions will be checked on text result '); 
            }else {console.log('\n\n ***** ONSTEP STARTING  at  index: ',step.index,'  thread : ',step.thread,' , obj result coming from GOTOTHREAD/REPLACEDIALOG or returning from child ');
            if(is_prevCollKey)console.log('   and as previous has a key ',is_prevCollKey,' registered onchange will be fired on result obj result'); 
            if(is_prevColl_Opt)console.log('   and registered  conditions  will be checked on obj result (??) ');       
            }
            if(lv>6)console.log(
            '\n   - vars is , ',step.values
            );*/
             //if(lv>4)console.log(' state vars is : ',step.state.values); 


             //// DIRECTIVE  ger fw directives : see // DIRECTIVE 

            let msgSent=-777,// an integer , the step to which the user answered (useranswer=state.userTurn), usually set as state.goon. -777 means no  text answer (result is obj )is  available from previous steps,-1000 result is null 
            state=step.state,
            askmatches=step.values.askmatches=step.values.askmatches||{};//;// to avoid error in case there is not fw support on this cmd
            step.values.matches=step.values.matches||{};//;// to avoid error in case there is not fw support on this cmd

            let goonDir = true,// default : do goon(mixedinitiuative) tech
                            // after will be overwritten by : excel.direc[previous.collect.key].loopDir.goon=false
                goonDir2=true; // will use past user text if available as state.userTurn . after will be overwritten by: excel.direc[previous.collect.key].loopDir.goon2=false
                if(step.values.session){
                step.values.session.activity=dc.context.activity;// add activity to vars . nb activity.channelData=message so is the body in a post !!
                step.values.session.body=dc.context.activity.channelData;}

                if(lv>3||loglv>3)logsout='\nconvId:'+dc.context.activity.conversation.id;// no insert chid
                else logsout=null;
                let count_;if(step.values.session)count_=step.values.session.dir.count;
                if(logsout)logsout+='\n *****   at current index: '+ step.index+' PROCESSING previous  ONSTEP of name: '+ prevName+ ' ,  thread: '+ step.thread+ ' cmd: '+ dc.activeDialog.id+' counter: '+count_;
                // + message body: vars.session.body or vars.session.activity.channelData


             if (
                 step.result &&
                 (typeof step.result === 'string' || step.result instanceof String)) {// >>>>> register last user turn on status for next step use

                 //   console.log(' onStepstarting , found string setting msgSent : ',step.index-1);

                 //okok :  can come from a runstep(....result) from a dc begindialog or from a step calling runStep(index+1,,result) but in this case we set goon as msgSent 

                 state.userTurn = step.result;// *** if this step will gotothread ( and begindialog,resumedialog ?), receiving step  will recover that text .( ) , as step.result (rally ? seems ok)
                 // >>>> step.state.userTurn can be nulled by onChange !!!!!!

                 // msgSent=step.index-1;// the
                 msgSent = step.index - 1;// the
                 //else step.state.userTurn=null;// when will i reset that ? never ? 

                 // moved from runstep :

                 // goon should warn that we goon to next step using a previous msg prompt , 
                 // >>>>>>>>>>>>>>>>  so shoud be index-1 otherwise should be index -2 ??
                 //if(state.goon||state.goon<=step.index-1){msgSent=state.goon;// usually step run with a user answare to msg of step with index-1 
                 if (state.goon != null && state.goon <= step.index - 1) {// if state.goon<step.index-1 the user answer refears to a step before the curret step (GOON detected ) , so we set  msgSent=state.goon (< index-1)
                     msgSent = state.goon;// usually step run with a user answare to msg of step with index-1 (previous msg)

                     /*
                     console.log('  result is text with GOON detected : last/previous step fired a runstep() with state.goon (so result , on which we are testing previous step condition, is a speech response of a msg before previous step ), thread: ',step.thread,
                     '\n    current index is ' + step.index ,' previous  index ( where we test the condition ) is ' , step.index-1 ,' text is ',step.result,
                     '\n   NB user answere referring to a older msg index: ',state.goon,' (setgoon is set in TTT when goon ) , to make it available in case of a gotothread the text was copied to state.userTurn ');
                     */

                     // 052021 : better not reset because if some condition will begin a dialog we cant came back in this entity but the child will start another entity and recover state !.
                    if(!goOnWOColl)     state.goon = null;// reset


                 }
                 // else msgSent=state.goon;???????????
                 /*
                 }if(msgSent> -777){
                       console.log('result is text because msgSent=',msgSent,'> -777 (-777 is obj result, so a goto thread/childreturn-replace...  dialog))  it can be the answer to a msg of a step previous than previous step !');
                 }else{  console.log('result is obj because msgSent=',msgSent,'== -777 , so a goto thread or a resume from child/...  dialog))  ');
                 */
//let a=this._vcontroller.init;
                ////// WARNING   is_prevCollKey = ' ' +  prevName    ?????????????????
                if(logsout){
                    if(is_prevCollKey)logsout+='\n  >> trying Matching  Previous Ask  '+ is_prevCollKey+ '  firing OnChange ';
                if (is_prevColl_Opt) logsout+='   And checking conditions';

                 if (msgSent < (step.index - 1))// msgSent is the step to which the user answered ,
                                                //  - if cur step is 0 :  msgSent=-1 means is the user text is the answer to the template of the step that goto this thread
                                                //                          but we'll test the user text againstt the step 0 condition in next step 1 
                     // - there is a user answer to text the condition ( > -777) on step at index=index-1
                     // - but (msgSent<step.index-1)the answer refears to a template in a  past/previous (msgSent<step.index-1) step , not the step where we are  evaluating condtion (index-1)
                     logsout+='  NB  GOON detected a previous user answer : so text result , to test previous step conditions at index: '+ (step.index - 1)+ ', is the user response to a prompt msg promped at a previous ask index: '+ msgSent;
                 else{
                     //console.log('  NB  GOON not detected a previous user answer : so test step condition on the user answer (text result) to template of same step . so text result , to test previous step conditions at index: ', step.index - 1, ', is the user response to the prompt msg promped at index: ', msgSent, '==', step.index - 1);
                    // instead : 
                    logsout+='  NB  GOON not detected a previous user answer :';
                 if(step.index>0)logsout+='   so test step condition on the user answer (text result) to template of same step . so text result , to test previous step conditions at index: '+(step.index - 1)+', is the user response to the prompt msg promped at index: '+msgSent;//, '==', step.index - 1);
                    else logsout+='  in this step 0 answer to previous step template , step ' + msgSent +' will be test on step 1';
              
                }
            }
             }
             else {// result is not string 

                ////// WARNING   is_prevCollKey = ' ' +  prevName    ?????????????????
                if(!step.result)msgSent=-1000;

                 if(logsout){logsout+=', on not a string RESULT , so result is not a user answer to current or previous step template but  coming from GOTOTHREAD/REPLY(result=null)/REPLACEDIALOG ( also returning from child)) is available. '+
                 '\n infact msgSent='+msgSent+'  <= -777 . nb indeed  -777: result is a OBJ , -1000 : result is null/undefined (a replay request )';
                 if (is_prevCollKey) logsout+='   On Previous step  '+ is_prevCollKey+ ' registered onchange will be fired on result ';
                 if (is_prevColl_Opt) logsout+='   and registered  conditions  that can work on a not text result ($$$ and $$$$) ($$ are processed but stdmatcher works only on text result), will be checked on obj result ';
             }
                }

             
 //             console_.log(3,logsout);
                // better provede 2 level of logging : winston.info(logsout);winston.debug?(logsout2);
                if(logsout){
                    winston.verbose(logsout);//winston.info(logsout);
             console.log(logsout);
             //if(loglv>3)logs(logsout);// usually logs=console.log
                }

        // a good point to stop watching 
           if(lv>6)console.log('\n   - vars is , ',step.values);
            step.msgSent=msgSent;
            // capture before values , now here not after !
            let index = step.index;
            let thread_name = step.thread;

function runChannelDataScript(that,previous){// previous can be previous or current when called ! 

// >>>>>>>> previous.channelData js run on previous step also if there are no collection. if we add channelData fields ok previous ask we can reply the ask so the ask send its template with its channelData fields 
if(previous&&previous.channelData){// custom fields are added here istead of PCC . so according to a prefined name of the field (key) do some action 
                // so cf can be found usually with following names:
                // key: '$$$$somename'   , run a eval 
                //      'dir-excel-entityname'  , insert value  in .dir.cond[entityname]
                //      'dir-direc' , insert value  into dir.sks[askname]
                                        

// can also run a micro onchange ??? : if key= run   eval value !!!!

// Custom Fields added in ask cms : copy all the values in channelData fields starting with 'dir-' as dirrective in a array
// seems ok put all directives in a dir obj 


for (var key in previous.channelData) {// for each custom field set in previous ask run exec $$$$
console.log(' convo ,  found custom field key  ',key);
if (key.substring(0, 4) == '$$$$') {
let param = {}, eret;
eret = looseJsonParse(null, step.values, step, previous.channelData[key], that._vcontroller.service, param,previous.channelData);
/* without param call back !
if (param.sF) {// conditon code set a async func service.... its param and a cb to set result in some vars
    //  let myf=new Promise(function(resolve){ param.sF(param.sP).then((x)=>resolve(x))});
    //let myf=async function(){return param.sF(param.sP);}
    //   rv=await myf;
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of

    // param.sF is set to some this._vcontroller.service[x]
    let rv = yield param.sF.call(this._vcontroller.service, param.sP);
}*/

} else if (key.substring(0, 10) == 'dir-excel-') {// a alternate way to set excel directive >>>> only in previous !!!!!!!!!!!
let ent = key.substring(10);
state.dir.cond = state.dir.cond || {};
stete.dir.cond[ent] = previous.channelData[key];
} else if (previous.collect&&previous.collect.key&&previous.channelData[key].substring(0, 9) == 'dir-direc') {// a alternate way to set excel directive 
//let askknam=previous.channelData[key].substring(9);
state.dir.asks = state.dir.asks || {};
state.dir.asks[previous.collect.key] = previous.channelData[key];
}
}
}
}
// 052021 : here or inside previous.collect case ???   PCC /PCC1
if(previous&&!previous.collect)runChannelDataScript(this,previous);

            if (step.result && previous && previous.collect) {// TESTING CONDITION  IF not null RESULT , step >0, ASK COLLECTING  !
                if (previous.collect.key) {


                    // capture before values // now done before 
                    // let index = step.index;
                    //let thread_name = step.thread;

                    /* DIR : doing DIRECTIVE  dir={event:function} event={convo,th,step}
                    nb ( custom field on a ask are put in line/previous/current.channelData)   
                    
                    
                    new 01062020
                        when find in custom field we put the field as is in state.dir.step[].custom
                            in begindialog  set also :  session.dir=state.dir



                    directives : question : is it better get a directive from the ask custom field in form of key='dir-th/ask/model-...'  or 
                            get it from excel. ....  ??
                    // state.dir={repeat:0,condDefInd:-1,condDefNam:null,maxrep:10};// put loop var/state in a specific obj : state.dir
                    //  ex : step-maxretry:....   , a general match   , a sentiment qualifier , a speech ... qualifier (group ) 
                    //  ex th-notmatchprompt x all step in a th 
                    // load dir temporarely on session.convo.dir.th/step from meta
                    if(previous.channelData){
                        vars.session.dir.run.curstepdef=-1;
                        // custom fields added in ask cms : copy all the values in channelData fields starting with 'dir-' as dirrective in a array
                        if(!vars.session.dir.step_v[previous])
                        for (var key in previous.channelData) {
                        if(previous.channelData[key].substring(0,4)=='dir-'){
                            vars.session.dir.step=vars.session.dir.step||{};
                            vars.session.dir.step[previous]=vars.session.dir.step[previous]||{};
                            let dir_=previous.channelData[key].substring(4);

                            if(dir_='maxrep'&&previous.channelData['dir-condDefInd']){// set som ctl vars
                                vars.session.dir.run.curstepdef=previous.channelData[key];// convert string to int
                                vars.session.dir.run.condDefInd=previous.channelData['dir-condDefInd'];// convert string to int
                            // todo so get condition index in case of vars.session.dir.step[previous][condDefNam]
                            }else{// just record it 

                                vars.session.dir.step[previous][dir_]=previous.channelData[key];
                            }
                        }
                        }
                    }
                    // ???
                    if(state.dir.repeat!=null)state.dir.repeat++;else state.dir.repeat=1;// ??? se fa runstep non repeat come faccio a capire di resettarlo ?
                    // following when evaluating condition condDefInd match the index 0 (?)
                    */

                    // 01062020  TODO lastly we introduced count so check if state.repeat is still valid 


                    /* moved before on 052021 
                        PCC
                    if(previous.channelData){// custom fields are added here . so according to a prefined name of the field (key) do some action 
                                            // so cf can be found usually with following names:
                                            // key: '$$$$somename'   , run a eval 
                                            //      'dir-excel-entityname'  , insert value  in .dir.cond[entityname]
                                            //      'dir-direc' , insert value  into dir.sks[askname]
                                                                    

                        // can also run a micro onchange ??? : if key= run   eval value !!!!

                        // Custom Fields added in ask cms : copy all the values in channelData fields starting with 'dir-' as dirrective in a array
                        // seems ok put all directives in a dir obj 


                    for (var key in previous.channelData) {// for each custom field set in previous ask run exec $$$$
                        console.log(' convo , there are step.result (no replay to just give prompt) and found custom field key  ',key);
                        if (key.substring(0, 4) == '$$$$') {
                            let param = {}, eret;
                            eret = looseJsonParse(null, step.values, step, previous.channelData[key], this._vcontroller.service, param,previous.channelData);
                            if (param.sF) {// conditon code set a async func service.... its param and a cb to set result in some vars
                                //  let myf=new Promise(function(resolve){ param.sF(param.sP).then((x)=>resolve(x))});
                                //let myf=async function(){return param.sF(param.sP);}
                                //   rv=await myf;
                                // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of

                                // param.sF is set to some this._vcontroller.service[x]
                                let rv = yield param.sF.call(this._vcontroller.service, param.sP);
                            }
                        } else if (key.substring(0, 10) == 'dir-excel-') {// a alternate way to set excel directive 
                            let ent = key.substring(10);
                            state.dir.cond = state.dir.cond || {};
                            stete.dir.cond[ent] = previous.channelData[key];
                        } else if (previous.channelData[key].substring(0, 9) == 'dir-direc') {// a alternate way to set excel directive 
                            //let askknam=previous.channelData[key].substring(9);
                            state.dir.asks = state.dir.asks || {};
                            state.dir.asks[previous.collect.key] = previous.channelData[key];
                        }
                    }
                        
                } */

                if(!goOnWOColl)runChannelDataScript(this,previous); // see PCC

                    // old : if(previous.channelData['maxrep'])if(state.count>=previous.channelData['maxrep'])setdef= condDefInd ;
                    


                    //console.log(' +++++++++++  previous ask ',previous.collect.key,' onchange , now vars is : ',step.values);

                    // capture the user input value into the array
                    if (step.values[previous.collect.key] && previous.collect.multiple) {
                        step.values[previous.collect.key] = [step.values[previous.collect.key], step.result].join('\n');
                    }
                    else {

                        step.values[previous.collect.key] = step.result;// here step.result can be   text or obj (if returning from child :rusult=step.values filled by child)


                        /* STUDIARE MODO PER INSERIE UN RISULTATO DEL CHILD SU UN MODEL ESISTENTE ES MODEL= ASKNAME , MENTRE IL PARAM PUO ESSERE  UN MODEL COL NOME DEL CHILD
                        ES NON CLONARE UN MODEL QUANDO CLONE IL VARS X CHILD in 
                        if(step.result&&typeof step.result !== 'string' &&){// >>>>> register last user turn on status 
                        }*/

                        if(step.result&&typeof step.result !== 'string' &&step.result.matches&&step.result.askmatches){
                            // returning from a child 
                            if(step.result.matches.return){if(step.values.matches[previous.collect.key])
                                                            Object.assign(step.values.matches[previous.collect.key],step.result.matches.return);// new : just overwrite, keep local vars
                                                            else step.values.matches[previous.collect.key]=step.result.matches.return;
                                // step.values.matches[previous.collect.key].fromchild=vars.session.processing ????? set the name of returning child 
                                                        console.log(' convo.onStep  found a Return from fw Child , so merge child matches.return model to matches.',previous.collect.key,'that is :\n',step.result.matches.return);}
                                                        console.log(' convo.onStep  found a Return from fw Child , without matches.return, in ask: ',previous.collect.key);
                        }
                    }

                    if(goOnWOColl)runChannelDataScript(this,previous); // run after set return from child , see PCC

                    // run onChange handlers
                    yield this.runOnChange(previous.collect.key, step.result, dc, step);// can set askmatches[previous.collect.key].param and .complete
                    // console.log(' +++++++++++ thread ',thread_name,', step ,',index,' is testing user answere on previous ask  ',previous.collect.key,' , onchange runned and  now vars is :\n ',step.values);
                    // did we just change threads ? if so, restart this turn
                    if (index !== step.index || thread_name !== step.thread) {
                        return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                    }
                }

                // Handle conditions of Previous Step 

                // logging 
                function ttest(tomatch,test){// tomatch MUST be text only !!!!!!!!!!!!11  , so test must be a regex string or a integer !!

                                            //  UNLESS 
                                            // - tomatch comes from $$$ condition that can set a model match or a vars evaluated tha CAN be of integer type
                                            //      in this case it will be tostring() and the test pattern must be like :'1234' so a number string  
                                            // - tomatch is a obj (child return .....) so can just goon if patt is *
// debug 30082021
                    if(tomatch=='678'){
                        let fr='l';
                    }


                    if(typeof tomatch !== 'string' ){ 
                        console.log(' convo.ttest(): WARNING term tomatch  is not a string , so must be a int!  and patt must be a int string ');

                        if(Number.isInteger(tomatch)){
                            if(typeof test === 'string'){
                            let myn=parseInt(test);
                            if(isNaN(myn))return null;
                           else{
                            
                               if(tomatch==myn){
                                console.log(' convo.ttest(): true as comparing int tomatch ',tomatch,' with int string patt ',myn);
                                return true;
                               }
                               else{
                                console.log(' convo.ttest(): false as comparing int tomatch ',tomatch,' with int string patt ',myn);
                                return null;
                               }
                           }
                        }else return null;

                        }else {// tomatch is not string , not int , so is a obj , match can be done unless test='*'

                             if(typeof test === 'string'&&test.charAt(0)=='*')return tomatch;
                            return null;
                        }
                        } else{// tomatch is string 
                                            
                    
                    // specuial case number natching 
                    // number can be present in tomatch if it comes from user speech its representaton will be '19' , oherwise it it come from a var ($$$ case)......
                    // number can be present in test if patt is set as number ( query model )
                    //      in this case better to def here a good regex x number case 
                    //      
                    //if(!isNaN(test)){// test is like a number , hope is a integer , better use Number.isInteger(test)
                    if(typeof test !== 'string' ){ console.log(' convo.ttest(): WARNING test pattern is not a string, so must be a int! ');
                    if(Number.isInteger(test)){
                        let myn=test.toString();// also -19 ?
                        test='\\b'+myn+'\\s*';// test tomatch string to find the number test  ex tomatch='i want the number 19 !' and test=19
                    }else return null;// test=test.toString();// very dangerous , better exit null
                    }    

                    // std case tomatch and test are strings 

                    // evermatch : set pattern=[\s\S]+ or :
                    if(test.charAt(0)=='*')return tomatch;

 
                    // experimental : only in case $xmodel:..§.....    so only when want to match a model not with theuser text but the text filtered by a regex group match  
                    // ex : $$_child:{£&}§1$vars.flag§modeldescription    it will match  the input=$vars.flag with modeldescription
                    //  ex $$_child:{£&}§1$vars.flag§some£*   route to _child    > so the receives a model with name _child matching matches._child.match=some and result =$vars.flag  
                    //          022021 ???, seems a way to load a vars value into a model match !
                    //      todo chech a error in this part of code  
                    if(test.charAt(0)=='$'){
                        // to test :
                        let avar=test.substring(1);
                        //if(test(0,5)=='vars.'){// error ???
                        if(avar(0,5)=='vars.'){// 022021

                        let term =looseJsonParse(null, step.values, step,avar,null,null,previous.channelData);// test with looseJsonParse(null, step.values, 'vars.result',null,null);
                        let rett;
                        if(term)rett= ['got',term];// 022021 : if the var vars.flag is true , it simulate a group match returning the group =term
                        //}
                        return rett;
                        }              
                    }


// todo  handle a invalid regular expression (UnhandledPromiseRejectionWarning: SyntaxError)  , see https://thecodebarbarian.com/unhandled-promise-rejections-in-node.js.html

                    let matres;
                    try{matres= tomatch.match(new RegExp(test, 'i'));// test='stay*\w*\s(\w*)' will return rematch=[],  in rematch[1] is the word after stay*
                    console.log(' convo.ttest() trying matching text ',tomatch,' with regex patt ',test,' got match : ', matres);}
                    catch{
                        console.error(' convo.ttest() got sintax err on regex : ',test);}
                    return matres;
                        }
                }

                function ahocorA(tomatch, patt){// https://github.com/BrunoRB/ahocorasick
                    // returns array with items , one each keyword matched , should also returns the kewords to match , or score =kewords matched / keywords to match 
                    // the separator must be | , cant be ' '
                    let keys='|';
                    //if(patt.indexOf('|')>0)keys='|';else keys=' ';// the separator must be | , cant be ' '
                    let skeys_=patt.split(keys);
                    const skeys = skeys_.filter(el => {if(el.length<4)return false;if(el.length>6)el=el.substring(0,el.length-2);return true;});// TODO : discard keys with length<3, steemmate dont work with filter
                    if(skeys.length>0){// TODO split also attributes id composed by more words. probably give less weight
                    let matches=new AhoCorasick(skeys)//['keyword1', 'keyword2', 'etc']); or ' ' if dont find any '|'
                    .search(' '+tomatch.toLowerCase());// add a blank space in order not to catch interkeys , nb patt=' word1| word2| word3', so must have word=' '+word_
                    // [ [ 19, [ 'keyword1' ] ], [ 47, [ 'keyword2' ] ] ]
                    let ret=[];
                    ret.push(matches.length);ret.push(matches.length/skeys.length);
                    return ret;
                    }else return [0,0];

                }

                if (previous.collect.options) {
                    var paths = previous.collect.options.filter((option) => { return !option.default === true; });
                    var default_path = previous.collect.options.filter((option) => { return option.default === true; })[0];
                    var path = null;


                    //// 052020 TRR : candidate to be executed on fw like :
                    // fwctl.f1();??? or can only be exported some functions ?

                    /// *****    TODO  TODO  TODO 
                    // check if this convo has fw support or not ( avoid check fw vars !!!!!!!)
                    /* example 
                    instead of :
                    if(askmatches[previous.collect.key]&&askmatches[previous.collect.key].param)
                    askmatches[previous.collect.key]={param:askmatches[previous.collect.key].param,complete:askmatches[previous.collect.key].complete}
                    else askmatches[previous.collect.key]=null;
                    put :
                    fwctl.addaskmatches(askmatches,previous);// reset all match key fields but not param (set by onchange) at start conditions loop p
                    ......
                    
                    */

                   
                    // 092020
                    // already done askmatches=askmatches||{},matches=matches||{};//;// to avoid error in case there is not fw support on this cmd

                    // step.values.askmatches[previous.collect.key]=null;// reset all match key fields but not param (set by onchange) at start conditions loop p

                    //122020 new reset askmatches before test the ask 
                    // we keep any settings that is not : .match .matched .vmatch  see format_v3.txt

                    /* if(askmatches[previous.collect.key]&&(askmatches[previous.collect.key].param||askmatches[previous.collect.key].params))
                        askmatches[previous.collect.key]={param:askmatches[previous.collect.key].param,
                                                        complete:askmatches[previous.collect.key].complete,
                                                        params:askmatches[previous.collect.key].params}
                    else askmatches[previous.collect.key]=null;*/
                    askmatches[previous.collect.key]=askmatches[previous.collect.key]||{};
                    askmatches[previous.collect.key].match=askmatches[previous.collect.key].matches=askmatches[previous.collect.key].vmatch=askmatches[previous.collect.key].nomatches=null;

                    function setAskDir(entity,previous,condition,state){// insert directives x the entity from condition macro :
                                                                        // state.dir.cond[entity]=JSON.parse(condition.macro)
                                                                        // if(state.dir.cond[entity].matcher) return state.dir.cond[entity].matcher

                        /* 092020 *** MANAGEMENT SUMMARY ON MATCHING and ROUTINGS 

                        macro conditions will set :
                         - directive in state.dir.asks[previous.collect.key].cond[Entity] , the Json in  macro field in a ask model condition ($xEntity:.....) ,
                                >> now state.dir.cond[Entity] 
                         if a model is many times called , only first occurence will set macro 
                         - return the  matchername  if found as directive in Json matcher property  or in model.js step.values.excel[entity].matcher
                              matcher will be fired, on MFM code section , that  ACCORDING to  condition.type will :
                                  - search in (onchange.js)_vcontroller.fwCb.askS[matcher] + _vcontroller.service[matcher];
                                  - fire the matcher 
                                  - store the REST dyn RESULT (Management) 
                                        (in in addMatcRes() ) in vars.askmatches and matches 
                                        >>>>  ACCORDING to  condition.type (cms if) request macro......  distinguish from :
                                        
                                                 
                                                      - a ask query,                          > store in askmatches structure 
                                                      - ask testing a intent resolution        > askmatches structure set in way like a dynquery are storen in a onchange 
                                                      - or a simple model match               > matches structure     set in way like a intent are storen in a onchange 
                                                 
                                                 
                          NB macro condition type is used to get a Matching Result 
                            a) match a entity  ( set result in matches) or 
                            b) resolve a intent ( so get its entities ) (set result in askmatches )
                                then if the Matching Result returns true ( a) ever ) we can ROUTE ( no continue or $% ) so  fire 
                                    - a microintent a)  or 
                                    - a macro intent b)

                            IF the Matching Result needs more TURNS a child will do that . 
                                so the condition needs to relay to it with a goto cmd dialog ( EXECUTE SCRIPT ) to fire the _Child with name starting with '_'
                                - a EXECUTE SCRIPT routing is transformed into a StartDilaog by cms system if the cmd name starts with '_'
                          
                          if the turn will not change we cn store the result in the same ask , otherwise a child will manage the turns needed
                        */

                        if(condition.type.substring(0,5) === 'macro') {
                            // fills directive field 
                                                       // session.dir=state.dir={asks:{ 
                                                        //                              askname:{cf:{cf1:'aval',,,,,},// custom field
                                                        //                                       >> WAS cond:{askconditionmodelname:condition.macro,,,},
                                                        //                                      },
                                                        //                                ,,,},
                                                        //                      NOW >> cond:{modelname:condition.macro,,,},
                                                        //                      }
                            if(!state.dir)return;
                            // let keyDir=state.dir.asks[previous.collect.key]=state.dir.asks[previous.collect.key]||{};
                            let mfound=false, keyDir=state.dir;//=state.dir||{};//=state.dir||{};
                            keyDir.cond=keyDir.cond||{};
                            if(
                                // !(keyDir.cond[entity])&&
                                condition.macro){// add this directive only if is void or add staff also  was not void ??
                                keyDir.cond=keyDir.cond||{};
                                //var str = '{ "name": "John Doe", "age": 42 }';var obj = JSON.parse(str);

                                if(condition.macro){
                                    // error 052021 : if(condition.macro.indexOf('&&')>0){condition.macro=looseJsonParse(condition.macro,Object.assign({},step.values,null,null,null));// try to calc vars between && && in macro json test :
                                    if(condition.macro.indexOf('&&')>0){condition.macro=looseJsonParse(condition.macro,Object.assign({},step.values),null,null,null,null,previous.channelData);// try to calc vars between && && in macro json test :
                                }
                                    keyDir.cond[entity]= JSON.parse(condition.macro);// load macro if found, overwritten, , cmsmacrojsonstring={ "matcher": "dynMatch" }'
                                console.log(' in previous mngment ,try matching condition on ask ',previous.collect.key,', found (in first if many) ',entity,' model json macro directive : ', condition.macro,' so : obj=',keyDir.cond[entity]);
                            }    
                            }
                                if(keyDir.cond[entity]&&keyDir.cond[entity].matcher){return keyDir.cond[entity].matcher;mfound=true;}// state.dir.asks[previous.collect.key].cond[entity].matcher="dynMatch"

                             if(!mfound&&step.values.excel[entity]&&step.values.excel[entity].matcher) return step.values.excel[entity].matcher;// try in excel x the matcher,will be called on MFM
                        }
                    }// end setAskDir()

                    

                    let p=-1;
                    for (p = 0; p < paths.length; p++) {// start CONDITION SCAN

                        let matcher=null;// standard matcher is ttest , in this case matcher=null

                        let condition = paths[p], 

                            tomatch = step.result;  // , ? rename it. per evidenziare ingresso da testare che puo essere user text, result from resume o altro obj settato in questo condition test testing code 
                                                    // >>> If calling from a ResumeDialig result can be the child vars that usually is assigned to the ask collect : vars.ask=result
                                                    //  SO before run a condition test that works only on text result (not $$$$ or $$$) on result that can came ALSO fron a cild return TEST IT :
                                                    //  resultisText=(typeof step.result === 'string' || step.result instanceof String))

                            if(lv>5)console.log('\n - TRYING CONDITION MATCHING  on  cmd: ',dc.activeDialog.id,', thread: ',thread_name,' ,on PREVIOUS step : index ', step.index-1,', ask ',is_prevCollKey,' . matching condition  number ',p,'\n     condition patt: ', condition.pattern,' condition obj : ', condition,' result/text_tomatch : ',tomatch);
                        let test,
                        notest = false,
                        patt;
                        let storemat = null,storeVal;// storemat is the item name (if the model is a number or just a regex match is called 'value' ) for menu model(static model + regex match group  in excel) 
                                                //  so 'value' if is an  integer or string entered /date  .... (match > storeVal=regex matched group) ex : user say 'il 3 ottobre' so storeval='03102020', storemat='value'  

                        if (condition.type === 'string') {
                           // test = new RegExp(condition.pattern, 'i');
                           if(typeof tomatch === 'string' )//dont run std matcher on child return (result is not string )
                            {
                            

                                if(tomatch.charAt(0)!='$'&&condition.pattern.charAt(0)!='$'){//if(tomatch.charAt(0)!='$'){
                                if (ttest(tomatch,condition.pattern)) {//
                                console.log('\n    >>  MATCH Detected on exact match : string condition ( number ',p,')matched at step index ', step.index,', condition : ', condition);
                                path = condition;
                                break;// break index p
                                }
                                console.log('\n    >>   NO MATCH on exact match : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);
                            }else{// a wrong type surely its not string , perhaps is regex at least !
                                console.error('\n error on condition type string , correcting in regex : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);
                                condition.type='regex';

                            }
                            }else console.log('\n     >>  NO MATCH : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);


                        }
                        let cc,ccc;if(step.values.session&&step.values.session.dir&&(cc=step.values.session.dir.count))ccc=step.values.session.dir.counter;
                        if (condition.type === 'regex'||condition.type.substring(0,5) === 'macro') {// not string pattern (REGEX_MACRO)
                            if(lv>6) console.log('condition matching debug : condition is regex or macro type, pattern:  ', condition.pattern
                            ,'\n session.dir.count= ',cc,' session.dir.counter= ',ccc,' vars is : ',step.values
                            );

                            /* in cms server public/js/section/...incoming..html : 
                            
                            <select class="ng-class: {invalid: option.invalid}; option-type conditional_select"  ng-change="makeDirty()" ng-model="option.type">
                        <option value="string">exact match</option>
                        <option value="regex">matches the regex</option>
			            <option value="macro_a">voice macro a</option>
			            <option value="macro_b">voice macro b</option>
			            <option value="macro_intent">voice intent</option>
			            <option value="macro_entity">voice entity</option>
			            <option value="macro_qs">voice querystring</option>
                        <option value="utterance">is a variation of</option>
                        </select>

                            */

                                        /* moved to ext func 
                                            function looseJsonParse(templ,vars){//extract in cond string a vars . format  xxxx&&vars.excel.....&&yyyy
                                            // see evalmozilla.js, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
                                            // call  ftempl=looseJsonParse(template,Object.assign({},context.vars,{aa}));
                                            // template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated

                                                // usually used in case we want to generate same text without use a onchange 
                                                // or also when in a msg we want to use a {{}} a context var depending from past status  
                                                // or in a condition we want to test not the user speech but the passed var got 

                                             let ioa = templ.indexOf('&&'),fcorpus,fc;
                                              let templP=templ.split('&&');

                                               //      console.log('looseJsonParse : templP is :',templP);
                                             //if (ioa > 0){let ioa1 = templ.indexOf('&&',ioa+3);
                                              //  if(ioa1>0)fcorpus = templ.substring(ioa+2, ioa1);}

                                              if(templP.length==3){
                                              // evaluate fcorpus in context 
                                                fc=templP[1];
                                                console.log('looseJsonParse : fc is :',fc);
                                                let myf='"use strict";' + fc;
                                                 let calc;
                                                // calc=Function(myf)();
                                                //calc=Function('"use strict";' + fc)();
                                                 //calc=Function( fc).call(vars);
                                                //calc=Function( fc).call(vars);
                                                calc=eval( fc);
                                                // OK calc=eval(myf);
                                                //   console.log('looseJsonParse  calc :',calc);
                                                if(calc)return templP[0]+calc+templP[2];
                                          
                                              }
                                              return templ
                                                                                  
                                             // return Function('"use strict";return (' + obj + ')')();
                                            }*/
                                        

                           function jVar(cod,vars){// returns the value of a vars.matches[cor].match  . cod can be :1  cod='avarwithnopoint' returns vars.matches[cod].match ,:2  cod='vars.askmodel.match.pippo' return the obj val
                            /*if(!cod)return rr, where rr is :
                            
 
                            condition regex patt example : $$mod_wh:where-dove|che posto|luogo&how-come|modo|devo|fare&when-quando|ora|orario|mattina|pomeriggio|sera|mattina
                                > will be cod='mod_wh'
                            
                                so, 
                                do case on regex patt in a ask condition :
                                1: if cod start with : $$ or $% or $$$    followed by xx&yy  :
                                    patt : $$cod&yy 
                                    >   cod is a model name(usually 'mod' followed by no points), jVar  returns : vars.matches[cod] (see addMatcRes for matches format )
                                2: if cod start with : $$ or $% or $$$    followed by vars.a.b.c&yy 
                                    >  cod=vars.a.b.c  is a obj name , jVar  returns : vars.a.b.c 

                            */
                               let qobj=cod.split('.');
                               if(qobj.length<2){// case 1 , cod is a model name so returns vars.matches[cod]
                                   
                                if(vars.matches[cod])return vars.matches[cod].match;// (see addMatcRes , model case ,  for matches format )
                               else return null;
                            }else{

                                return getCodedVar(vars,qobj);
                               }
                               function getCodedVar(vars,qobj){return iterdepl(vars,qobj,qobj.length)}
                               function iterdepl(vars,namwp,pos){// pos=point position,'vars.askmodel.match.pippo' >  namwp= ['vars','askmodel','match','pippo'] initial pos=namwp.length 
                               // will return vars obj as required by literal string namwp
                               let ll=namwp.length,step=ll-pos;// step =0 ... ll-1     max :  ll-1=step=ll-pos  >> pos=1
                               if(step==0){if(namwp[step]=='vars')  vars=vars;// must start with vars.
                                            else return null;}
                                else{
                                    vars=vars[namwp[step]];
                                    if(vars);else return null;
                                }

                                if(pos<2){// at the end 
                                        return vars;
                                }else{
                                    pos--;
                                        // here pos>=1
                                        return iterdepl(vars,namwp,pos);
                                }

                               }



                           }// end function jVar


 // ******* model matching section 




let mgot=false;// .......

if(condition.type.substring(0,5) === 'macro') {// macro only 

}// end  macro only

const C_$$=0,// type $$, the current entity conditional case in testing 
    C_$p=1,// type $%
    C_$$$=2,
    C_$m=3,// Sxsomename:>
    C_def=4;// usual regex
let cond_type=null;

                       if(!mgot){//hyt
                            let is$p=false;
                            if (condition.pattern.substring(0, 2) == '$$' || (is$p=condition.pattern.substring(0, 2) == '$%')) {// $xy cases : todo add a $% that means try match , register , but no stop current condition testing, so no route
                                //  console.log(' condition matching : $$ case pattern is  ',condition.pattern, ' patt is : ',condition.pattern.substring(2,condition.pattern.length));
                                cond_type=C_$$;if(is$p)cond_type=C_$p;
                                let linematch = condition.pattern.substring(0, 2) == '$$';// if model matched match the line if not previously done, then if matched route ($$ case)  otherwise goon to test all other conditions

                                //052020
                                let itr = condition.pattern.indexOf(':'),//  : position , example in '$%entityname:....'    itr=12
                                entity;// put after     entity = condition.pattern.substring(2 + sk_, itr);// mod_loc   $$mod_loc::   means look in model definition. see excel .....

                                // do a version x  if(condition.pattern.substring(0,3)=='$$%')// recover the value values[ioafild].match
                                if (condition.pattern.substring(0, 3) == '$$$')// recover the value  values.matches[ioafild]
                                {// start $$$ and $$$$ case 

                                     cond_type=C_$$$;


                                    if (condition.pattern.charAt(3) != '$') {// regex example : '$$$location&gigi||luigi  patt='gigi||luigi'   ioafild='location' is a model or a var... to test
                                                                            // $$$vars.askmatches.....:aregex
                                                                            // $$$vars....:$vars......  ??? can be easier to do with $$$$ !
                                        let ioa = condition.pattern.indexOf('&');// pattern(conditiuon field)   is :  $$$valuetotest&aregex        ,  valuetotest is a model name  or var......
                                        if (ioa < 0) ioa = condition.pattern.indexOf(':');// pattern(conditiuon field)   is :  $$$valuetotest:aregex        ,  valuetotest is a model name  or var......
                                        if (ioa > 0) {

                                            patt = condition.pattern.substring(ioa + 1, condition.pattern.length);
                                            let ioafild;// &&&
                                            ioafild = condition.pattern.substring(3, ioa);

                                            if(ioa>7&&ioafild.substring(0,5)=='vars.'){// $$$vars.....:aregex , ioafild='vars....' patt='aregex' . extract vars....   using looseJsonParse
                                            //entity=condition.pattern.substring(3, ioa);
                                            //if(state.dir.cond[entity]&&state.dir.cond[entity].term){// the var to take as input , ex ''vars.result' x user text 
                                            let term =looseJsonParse(null, step.values, step,ioafild,null,null,previous.channelData);// test with looseJsonParse(null, step.values, 'vars.result',null,null);
                                            if(term)
                                            tomatch=term;else tomatch=null;// cant match
                                            //}

                                            }else{

                                            //tomatch = step.values.matches[ioafild];// to test if tomatch  match with pattern patt  
                                            tomatch = jVar(ioafild, step.values);//ioafild is the model name , to match  is a string ,the item value/key , not the voice name 

                                                    // ****************   TODO : calc as looseJsonParse , will be easier and can eval all vars not only model matches !

                                            console.log(' try matching condition  :  $$$amodel:pattern . amodel(modelname or vars...): ', ioafild, ' matches item: ', tomatch, '  pattern to test: ', patt);
                                            }
                                            if (!tomatch) notest = true;
                                        } else notest = true;


                                        //test = new RegExp(patt, 'i');


                                        if (!notest && ttest(tomatch, patt)) {
                                            console.log('\n    >>  MATCH Detected : $$$ condition  ( number ', p, ') matched  at step index ', step.index, ', condition : ', condition);
                                            path = condition;
                                            break;
                                        }else console.log('\n   >>  NO MATCH : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);


                                    } else { // $$$$ case is a js function returning tru if condition matches 
                                        // TODO: Allow functions to be passed in as patterns
                                        // ie async(test) => Promise<boolean> x promise use of async helper func passed as vars.helper see :
                                        //      cms_onchange_function_andasync.js

                                        // example :
                                        // $$$$let out, geta=vars.results.match(new RegExp('collect*\w*\s(\w*)', 'i'));if(geta){vars.getta=geta;out=true;}else out= false;  // test='stay*\w*\s(\w*)' will return rematch=[]

                                        // add text to vars as vars.result:
                                        step.values.result = tomatch;// step.values=vars=Object.assign({},step.values,{result:tomatch}) not necessary to clone
                                        let param={},eret;
                                        eret=looseJsonParse(null, step.values, step,condition.pattern.substring(4),this._vcontroller.service,param,previous.channelData);

                                        if(param.sF&&param.sP&&param.cb){// conditon code set a async func service.... its param and a cb to set result in some vars
                                         //  let myf=new Promise(function(resolve){ param.sF(param.sP).then((x)=>resolve(x))});
                                         //let myf=async function(){return param.sF(param.sP);}
                                         //   rv=await myf;
                                         // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
                                         
                                         // param.sF is set to some this._vcontroller.service[x]
                                         let rv=yield param.sF.call(this._vcontroller.service,param.sP);

                                            // matcher caller must comply param to service call (interface def)
                                            // can be :
                                            // - sF=rest_run that do same job as def matcher service , dynmatch, but is called with different param :
                                            //      infact we dont have to match some entyty with some dependings where model but provide the rest qs !!!!!
                                            // 



                                           if(rv){ param.cb(rv);

                                            // >>>>>  nb remember that run_jrest generally returns {reason,rows} and run_rest returns a string 

                                            console.log(' $$$$ function condition requested a SERVICE function: ', param.sF.name,' and succeeded , result: ',rv);
                                            
                                           }else console.log(' $$$$ function condition requested a SERVICE function: ', param.sF.name,' and dont succeeded ');
                                        }
                                        if (eret) { // a function as tostring
                                            console.log('\n   >>   MATCH Detected : $$$$ function condition with vars.text in scope  ( cond number ', p, ') matched  at step index ', step.index, ', condition : ', condition);
                                            path = condition;
                                            break;
                                        }else console.log('\n   >>   NO MATCH : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);
                                    }// ends $$$$ case


                                }// ends $$$ case 
                                else {// $x case can be $$ (test and condition route ) or $% (test and not condition route ) or $$% $%% (% in 3rd position means to test anyway )
                                    // add a $$mario-mario*&second item ....
                                    // for   {nextitem=condition.pattern.indexOf('&');  No ?  just one item x condition ?!!!

                                    // >> better put the matched result in a dedicated value.matches.entity
                                    // the match can be done in many condition or just one :
                                    // $$entity_name:ma-mario*&gi-giovanni :
                                    // entity='ma' or 'gi'

                                    // a json format can be used !
                                    // $$entity_name:pattArray     so :

                                    // $$dyn_medicine:itemnam1-pattern1&itemname2-pattern2......  OR get model  $$dyn_medicine:: OR select adynquery   $$dyn_medicine:>
                                    let 
                                    //itr = condition.pattern.indexOf(':'), 
                                    pattArray,
                                     pArray,//  pattArray='item1-pippo!poppo*&item2-parerino&..',pArray={item1:{patt:'pippo!poppo*',(name/value:item1,),,},item2:{patt:'parerino',,},,}
                                     medSync;// medSync[] contains the key  of pArray , describing the match/selectionpattern data, to select item i, or null if is filtered ( not matchable)  
                                    let sk_ = 1, retest, chmatch,
                                        prevMat;


                                    let desiredE,des, cursor, param;// a desire ask query result field , in case a selection will be required by some condition :$$desire_ask: or :$$desire_model: ; 
                                                                // param can be param or intent
                                                                //  des = the desire  : param=(ask)matches.desire
                                                                // param = the desire model : param=des. intent/param =(ask)matches.desire.  intent/param                      


                                    if ((retest = condition.pattern.charAt(2) == '%'));// overwrite test ( reset and do $% case ) , $x%entity....    case
                                    else if (chmatch = condition.pattern.charAt(2) == '§') {// $x§entity....   case  , we test also if it alredy matched and if matches overwrite previous match !
                                        //prevMat=step.values.matches[entity]
                                        ;
                                    }// check if matched changed , to do , usefull ??? , only if  $%§ : if dont match leve previous !
                                    else sk_ = 0;// no third ctl char

                                    if (itr > 0) {// start case model match with a $X(Z) case : start $  then % or$ then optional % or § :
                                                // and < 20  , a model match with entity name (<entityname>) declared : $X(Z)<entityname>:...  Z can be % or § ,  X can be $ or % 
                                        

                                        if (condition.pattern.charAt(itr + 1) == ':') {// $%%mod_Serv:: , second ':'  means look in model definition. see excel .....
                                            // case  $$mod_Serv::   >>>   excel declaration : of entity mod_Serv

                                            //  in cms condition :        '$$mod_Serv::' as regex type

                                            // in excel , def will be in (dejson from a string ):

                                            //  excel:{,,,,
                                            //      mod_Serv:{
                                            //          ,,,,

                                            //         model:{bar:{// a instance of the model
                                            //                      patt:ristorant*|pranzo|cena|trattoria',
                                            //                      ai_url:'',
                                            //                      vname:'',,,}
                                            //                  ,,
                                            //          },
                                            //          ,,,
                                            //      },,,
                                            //  }



                                            //052020
                                            entity = condition.pattern.substring(2+sk_, itr);// mod_loc   $$mod_loc::   means look in model definition. see excel .....
                                            // model:'bar-bar&rest-ristorant*|pranzo|cena|trattoria&port-portin*|recept&pisc-piscina&lav-lava*puli*&col-colaz*|brekfast'

                                            // model definition is get from excel[entity].model :
                                            if (step.values.excel[entity] && step.values.excel[entity].model) pattArray = step.values.excel[entity].model;// get voice entity name from excel
                                            // matcher=// no custom matcher needed if model is described in excel ??
                                           let matcher_= setAskDir(entity,previous,condition,state);// get macro to set session.dir run time directive but not use the matcher setting , we use std REGEX matcher 
                                            //if(state.dir.asks[previous.collect.key].cond[entity]= JSON.parse(condition.macro))
                                            console.log('convo.onstep, condition matching debug : $$ case pattern is $$xxx:: model declared on excel , matcher detected but not considered :',matcher_);

                                        } else if (condition.pattern.charAt(itr + 1) == '£') {// $£:: 
                                                                                            // 012021 : try to remenber its use : seems we need this functionality in child where in a ask in def thread gather special info about the child behaviour 
                                                                                            // probably we want to check if the dialog can continue in child or should be interrupted to return control when one model of the list matches
                                                                                            // models must be declared on excel  

                                             // HERE WE CAN GET A INTERRUPT BUNCH : a list of entity model found in askmatches associated with the child :askmatches._child.params.inter=[amodel_in_excel_1,,,,]
                                             // for each model in INTERRUPT BUNCH we 
                                                let ints;
                                                if(askmatches[this.id]&&askmatches[this.id].params.inter&&( ints=askmatches[this.id].params.inter.length)>0){
                                                    for(let ii=0;ii++;ii<ints)// for each model in int list : test this model ( in excel) 
                                                    
                                                    {let int=askmatches[this.id].params.inter[ii];
                                                                if(step.values.excel[int].model){
                                                                    pattArray = step.values.excel[entity].model;


                                                                    // 012021 : ERROR  let stdmres=stdMatch(pArray,pattArray,linematch,step,null);//return {matched,path,rematch,storeVal,notest};
                                                                    let stdmres=stdMatch(pArray,pattArray,linematch,step,null);//return {matched,path,rematch,storeVal,notest};
                                                                    if(stdmres.matched){// interrupt got in testing the model in ask interrupt bunch 

                                                                        addMatcRes(true, null, null, p, true,true);// if a condition with no model, like this one,  matches we register a match using the index {ind:4} and not its name {key:value}
                                                                        // add int match also in askmatches complete 
                                                                        askmatches[this.id].complete='inter';
                                                                        path = condition;
                                                                        break;// break ii index

                                                                    }
                                                                }

                                                    }
                                                    if(ii==ints)break;// break index p
                                                }
                                                console.log('convo.onstep, condition matching debug : $$ case pattern is $$xxx:£ model array of excel models ');
                                        } else if (condition.pattern.charAt(itr + 1) == '>') {// $$dyn_medicine:>
                                            cond_type=C_$m;
                                            /**
                                             * $$dyn_medicine:> will look for a model description on askmatches[dyn_medicine] or matches[dyn_medicine] :
                                             * 
                                             * pArray=(ask)matches[dyn_medicine].param.cursor.resModel={val1:{
                                                                                                            patt:regexstr,
                                                                                                            vname:'pippo'
                                                                                                            },,,}
                                             * 
                                             */


                                            /* **** this condition,
                                                  supposing the user knows the pattern to get a match on some item of the query result cursor got in its step.values.askmatches[desiredE] onchange(),

                                                    TRY TO  DO   selection on a ask desiredE ($$desiredE:>) cursor : step.values.(ask)matches[desiredE].param.cursor ( many rows results )
                                                    >> so create on fly a matching model as :  pArray=cursor.resModel, named entity=askname!!!!!
                                                        then , if a match has got at index i=blRes in pArray, in addMatcRes()  we set  :

                                                         - step.values.askmatches[desiredE].param.group.sel=   
                                                                ={item:mydata[blRes],index:blRes};// (can be default if no selection done ( in this case mydyn.param.group.def is null)
                                                         - temporely add also (to distiguish a query with 1 row and a query selected by some other ask):
                                                           step.values.askmatches[desiredE].param.selmatched=
                                                                =previous.collect.key // the .sel is set by a other ask selecting  a cursor with many rows 


                                                    **** question : these are set also by this selecting ask ,not only by desiredE query if lenght =1  ??????????
                                                            param.match=blResNam;//=blResItem[1];//  cursor matched item name ( and item copied to .sel)
                                                            param.vmatch=blResItem[12];//   cursor matched item vname ( and item copied to .sel)
                                                    ..... and other details see addMatcRes() 
            
                                            */



                                            // example $$dyn_rest:>  > will select on the query result  in vars.askmatches.dyn_rest.param.cursor.rows ( a array)
                                            //          nb the normal  ask containing this '$$desiredE:>' resolver condition will be preeceeded by a msg 
                                            /*  prompting user to select from a voice item list :

                                            {{#mustacheF.out}}$$list&12& 
                                            le medicine che devi ancora prendere questa mattina sono :<br>
                                            {{#dyn_medicine.param.cursor.rows}}
                                             {{mustacheF.rendQuery}}
                                            {{/dyn_medicine.param.cursor.rows}}
                                            {{/mustacheF.out}}
                                            */


                                            /* OLD STAFF , TO LEAVE OR TOREVIEW ::
                                            // so
                                            // the case ':>' instead of '::' will : 
                                            //     In case is a cursor on a data desired entity associate with a key=dyn_rest we build the model on data matrix 
                                            //          data = desire entity with bl data and inflacted with join where

                                            // let previous key=collect.key=CK 

                                            //  - the cursor is a array with 0/1 param.match... ( non just param.def and param.sel ) (the entity instance matching  called group)
                                            //    - the selection is a vars.askmatches.CK.param.group.sel ( a bl map of a entity instance as usual in colazione ) 
                                            //  - the model is a projection of the bl matrix on the patt col

                                            // so that means we consider a model named mod_CK got as the col_i of the entyty associated with 
                                            //  the desidere ask( the dyn_rest )
                                            // KKJJ
                                            // after as usual   ... got the match we fill a usual desire selection entity setting :
                                            //  >  vars.askmatches.CK.param.group.sel=dataof_dyn_rest[indexmatched] and used in template as would be the vars.askmatches.dyn_ask.param.group.sel
                                            //  excel:{,,,,
                                            //  }
                                            */
                                            cursor = null;// calclate param from desire ask onchange()

                                            desiredE = condition.pattern.substring(2 + sk_, itr);// mod_loc  ,  des in  $$des:>pippo
                                            // model:'bar-bar&rest-ristorant*|pranzo|cena|trattoria&port-portin*|recept&pisc-piscina&lav-lava*puli*&col-colaz*|brekfast'
                                            // mydyn.param.cursor={matches,patt}
                                            des = askmatches[desiredE]||step.values.matches[desiredE];// search x runtime model var.askmatches.desiredE or var.matches.desiredE
                                            

                                            // SET the name of the generated selector model match status : matches.entity
                                            entity=condition.pattern.substring(itr + 2);// pippo in  $$des:>pippo
                                            if(!entity||entity.length<=0)// !!!! TRPK
                                            entity = // the generated model name that will do the desire rows selection (same name of the ask !!!!!!!!!!), ;
                                            // its a model generated at run time (desire.intent/param.cursor...)to select an item of a dyn_ask master/ detail query ((askmatches.someask.param.cursor.resModel))  (same name of the ask !!!!!!!!!!)
                                                previous.collect.key;// or better : 
                                                // des;    //itself : write the selection on the same desired ( matched=best when selected become matched='matched') . >>> todo or not todo ?????????????      
                                                
                                                
                                            // reset the entity just in case alredy matched in past 
                                            // infact the matching is done if :
                                            // - related entity is not matched 
                                            //   OR 
                                            // - the desiredE is not matched  !!!!!!!!!!!!!!!!!!!!!!!!!!!

                                            if(des&&!des.match)// force null the entity match if is so in the desiredE
                                            if (step.values.matches[entity]) {// if exists, attach the sel model to matches
                                                step.values.matches[entity].match = null;step.values.matches[entity].matched=null;
                                                // needs ? step.values.matches[entity].mid=-1;
                                            }

                                            // param = the desire model : param=(ask)matches.desire.  intent/query-param
                                            // change param > query ?
                                            if ((des && (param=des.param)&&des.param.cursor && (pArray=des.param.cursor.resModel))||
                                                (des&&(param=des.intent)&&des.intent.cursor&&(pArray=des.intent.cursor.resModel))) {// the query/intents has many rows
                                               // param = des.param; cursor = param.cursor;// des.param.cursor={rows:res.rows,resModel:{}}
                                                /*
                                                     resModel={val1:{
                                                                     patt:regexstr,
                                                                    vname:'pippo'
                                                                     }
                                                    }*/
                                               // pArray = cursor.resModel;// the model to select an item
                                                // 12042020 , did ok . 
                                                // old , discard 
                                                //  TODO check if KKJJ would work 
                                                // (the view just chech if there is a single selection ...param.group.sel or manyrows in cursor )or instead do as following :
                                                // IF MATCHES   WILL can set a model refearring to the name/id of the master query so we can run the query so will got a single row
                                                // so group view will show params ( mod_wh ) for a single row !!!


                                                    // to manage filtering on pArray look for sync it sync array too :
                                                    if (des.param&&des.param.cursor.medSync){
                                                        medSync=des.param.cursor.medSync;
                                                    }






                                            }else {pArray={};}// a void model : never match no match . reset also pattarray to double check ? 
                                            // like in onchange runQuery we define a param result (passed to addMatcRes()) of  a query ask match:
                                            // mydyn=askmatches[entity]={matched:null,complete:'fail'};

                                            console.log('convo.onstep, condition matching debug : $$ case pattern is $$desiredE:>yyy , desire model to select is (ask)matches.desiredE.param/intent , if matched selector model generated is matches.yyy (if yyy is null yyy=ask  )');
                                            console.log('   desiredE is: ',desiredE,' , yyy: ',entity);

                                        }// end $$adynaskquery:>
                                        else {// condition in line declaration >  $$entityname: or $$%entityname: or $%entityname: or $%%entityname:
                                                // do same things we do if the model is declared in excel ( case $xyentityname::)
                                                // but here we can have matcher set 

                                            // a MODEL/Entity FOUND to MATCH (no Excel (model.js)  Model definition ) so can be :
                                            //     -  std Inline Regex Matcher 
                                            //      or can be a 
                                            //     - Matcher service

                                            //   condition declaration :
                                            //          $$mod_Serv:bar-bar&rest-ristorant*|pranzo|cena|trattoria&port-portin*|recept&pisc-piscina&lav-lava*puli*&col-colaz*|brekfast


                                            pattArray = condition.pattern.substring(itr + 1, condition.pattern.length);//substring(itr,nextitem-1)
                                            entity = condition.pattern.substring(2 + sk_, itr);
                                           
                                           // 
                                            matcher=
                                            setAskDir(entity,previous,condition,state);
                                            console.log('convo.onstep, condition matching debug : $$ case pattern is model declared inline , matcher detected: ', matcher);

                                        }

                                    } // ends case model match

                                    else { // match text against single condition pattern, not a model with many entities . seems an error / not possible 
                                        // TODO : better exclude this case 
                                        // WARNING here we have $$....................     with no :   so ERROR 
                                        console.error('probably ERROR in pattern format , cant be $$ without :')
                                        entity = previous.collect.key;// WHY ???????? what to do with this entity ????
                                        pattArray = condition.pattern;
                                    }
                                    // pattArray='ma-mario&lu-luigi|gigi'

                                    // todo if $% and alredy matched we dint need to retry matching !!!!!!!!!!
                                    let matched = false,// matched before or in this test 

                                        rematch;// the regex extraction ( due to ()) used in  addMatcRes , bad name !!

                                    // gives error : if(chkMatcRes(entity)==null){ //  if didnt match do it 
                                    // so :
                                    if (!retest && chkMatcRes(entity)) {
                                        //  it already matched , so if is $$ we must stop testing the loop and route

                                        //  if chmatch true : store previous past match. if exists past match  and we dont match current restore past match
                                        if (chmatch) prevMat = step.values.matches[entity];// is also :matched=false
                                        else {
                                            matched = true;

                                            if (linematch) path = condition;// do not route if is $%  0503
                                        }
                                    }

                                    // DO MATCHING PHASE

                                    if (!matched) {// start  if didnt match do it  , or retest , or chmatch to do , do it 
                                        //step.values.matches[entity] = null;// 012021  ERROR , cant  reset previous match 
                                        if(step.values.matches[entity]){// retest anyway, leave complex attribute ,
                                                                            // if the entity has complex structure we cant null it , just null the .match,matcher,vmatch and instance matching attributes !!!
                                                                            step.values.matches[entity].match=step.values.matches[entity].matched=step.values.matches[entity].instance=null;
                                                                        }
                                        matched = false;
                                        let itemb;
                                        let ii = 0;

                                        if(!matcher){// special matcher is missing , so  a std matcher regex
                                             // FFRRT
                                            if((pArray||pattArray)&&tomatch){

                                           let stdmres=stdMatch(tomatch,pArray,pattArray,linematch,step,entity,medSync);// returns {matched,path,storeVal,notest,storemat};
                                                                                                                //  old : return {matched,path,rematch,storeVal,notest,storemat};
                                           // storemat is the item matched/value in case of regex group ( put in storeVal);rematch is the 
                                          // old  matched=stdmres.matched;path=stdmres.path;rematch=stdmres.rematch;storeVal=stdmres.storeVal;if(stdmres.notest)notest=true;
                                          matched=stdmres.matched;// the matching result (match if is not false or not null )
                                          path=stdmres.path;
                                          storemat=stdmres.storemat;// the matching item in ,pArray/pattArray
                                          storeVal=stdmres.storeVal;// the calc  item in ,pArray/pattArray // regex group ( int, group string)
                                         ii=stdmres.storeMId// the matching index in ,pArray/pattArray

                                          if(stdmres.notest)notest=true;
                                            } else console.error('probably ERROR  cant run     std Match er    on entity ' ,entity,'  as cant find staff . now goon considering false the match ')
                                    /* moved to stdMatch()

                                        let  itr1;// when 0 stop while

                                    // 072020
                                    // pattern description x regex entity
                                    // base format pattArray={itema-regexa&itemb-regexb&.......}
                                    // if firse 4 char is : {xy}, take x instead of - and y instead of &
                                    let itemSep='&',nameSep='-';
                                 
                                        if (pArray) itr1 = Object.getOwnPropertyNames(pArray);
                                        else {
                                            // TODO TODO todo : do the same on mod_feature branch
                                            if(pattArray.length>7&&pattArray.charAt(0)=='{'&&pattArray.charAt(3)=='}'){// set x,y
                                                itemSep=pattArray.charAt(2);nameSep=pattArray.charAt(1);
                                                pattArray=pattArray.substring(4);
                                            }
                                            itr1=pattArray.split(itemSep);
                                        }

                                        for (ii = 0; ii < itr1.length; ii++) {// gh for all item in model test it 
                                            // start  condition try matching 


                                            // TESTING from the declared entity in excel :  
                                            //                                      if the entity is described in excel ( in excel every item has a name and a patt and a vname , and can have description and some bl values )
                                            //                                              we test its item :
                                            //                                              itemname storemat with pattern patt  
                                            //                                     if the entity is described in excel just with the entity name and the algo/external REST url that will resolve
                                            //                                               we call the name resolved by external algo 'value' and the resolved  matching entity ( atomic or obj ) are put in storeval
                                            if (pArray) {
                                                patt = pArray[itr1[ii]].patt;
                                                storemat = itr1[ii];
                                                console.log(' condition try matching : $$ case , ii: ', ii, ' item (storemat) :  ', storemat, ' on patt : ', patt);
                                            } else {
                                                let sar;//=itr1[ii].split('-');//better as the regex can contains '-' , so itr1[ii].indexOf('-');
                                                //sar = itr1[ii].indexOf('-');
                                                sar = itr1[ii].indexOf(nameSep);
                                                if (sar >= 0 && sar < itr1[ii].length + 2) {// >1 2 ?

                                                    storemat = itr1[ii].substring(0, sar);
                                                    patt = itr1[ii].substring(sar + 1);
                                                    console.log(' condition try matching : $$ case , ii: ', ii, ' item (storemat) :   ', storemat, ' on patt : ', patt);

                                                } else notest = true;
                                                // end for 
                                            
                                            }
                                            
                                            // test = new RegExp(patt, 'i');


                                            // TODO: Allow functions to be passed in as patterns
                                            // ie async(test) => Promise<boolean>

                                            // *** TRY MATCHING iesimo item in Entity Model
                                            if (!notest && (rematch = ttest(tomatch, patt))) {// rematch means 'match result'. match if ttest returns a not null rematch. rematch[1]>matches.entity.
                                                // ok : 
                                                console.log(' \n * MATCH Detected on MODEL :$$ or $% condition, at thread ', thread_name, ',step ', step.index, ' ,previous ask key ', previous.collect.key, ' ,ask condition index ', p, '\n  model  ', entity, ', matched model item : ', storemat, ', model index : ', ii, ', extracts: ', rematch);
                                                step.values.__conf = step.values.__conf || '';// confirm  the user matched something 
                                                //if(data !== null && data !== ''  && data!==undefined) {}  You can use below simple code
                                                // if(Boolean(value)){ 
                                                if (rematch.length > 1 && Boolean(rematch[1]) && storemat == 'value') {// manage a value :the 'item name' is 'value' , it assumes the matched val that must be first group

                                                    storeVal = rematch[1];

                                                    // step.values.excel[entity].vmatches.value;// is not used 
                                                    step.values.__conf += storeVal;
                                                } else {// manage a entity item name : recover the vname from excel model 
                                                    storeVal = null;
                                                    // recover vmatch if present on model
                                                    if (step.values.excel&&step.values.excel[entity] && step.values.excel[entity].vmatches) step.values.__conf += step.values.excel[entity].vmatches[storemat];// get voice entity name from excel
                                                    else step.values.__conf += storemat;
                                                }

                                                if (linematch) path = condition;// do not route if is $%

                                                matched = true; break;// break ii loop, (loop: in a $xy condition for all item in model test it )
                                            } else {// 
                                                //  addMatcRes(false,entity);
                                            }

                                        }//  end condition try matching. gh  end ii for , test item in model
                                         // ends moved to stdMatch()
                                         */

                                    }else{// a not std matcher (a not regex matcher)


                                        /* 012021  review
                                        
                                        not std MATCHER main LOGIC :

                                        fire the matchers helper that return val=VAL ,see chart on VAL

                                        on cb(val) :
                                        - set the matcher status  at complex level (matches.some.entity.match... )x all type of model : query,intent and entity : 
                                            - match,matches,vmatch, instance
                                            nb match is the row.value of the matching rows if matches
                                            - entity and intent ever matches
                                            - after , in onchange.js.addMatchRes() using pArray||pattArray , match,matches,vmatch, instance will be copied at base level (matches.some.match...) after some change , 
                                                for example match at base level can be a different column ex:
                                                .rows[{value,,,city:'padua'}] will have
                                                    matches.some.entity.match=.rows[0].value    
                                                    but if $$anentity:city-x   + entity directive on macro :
                                                        matches.some.match=.rows[0].city='padua'


                                        */

                                        // ****  MFM code section : fire a matcher and insert the result depending on the request type ( usually looking at condition.type  )

                                        /* remember MNG SUMMARY main logic on  setAskDir()
                                            *** , 22102020 MNG SUMMARY main logic, see also matches_askmatches_logic&api.master.txt :
                                        - matchtyp will check that matcher can be processed by the current condition , as matchtyp api requires
                                        - convo std/notstd matcher usually is , a service (a match helper like intMatch,dynQuery or dynMatch) that convert the format of a external run rest service (run_jrest())
                                                nb run_jrest() give int/ent match (or a partial info ( ex cursor describing the master query/model to select)to resolve in  next turn in a relayed thread or  with the help of a child working on the entity var )
                                             to a format defined by the matcher type
                                            , so matcher according its type ( query,entity, intent) will add/ update some fields of and pass matched,storemat/storeVal to addMatcRes(matched,storemat/storeVal ) that according to type will:
                                                    - set condition match .matchers.modelassociatedwithcondition (as booleanevententity associated with condition   or the modelitself ASSK )
                                                    - set the ask matches about condition askmatches.match/...
                                                    + add set the associated target entity in a proper var for following turn process , 
                                                            - usually is easy to set embedding into the askmatches.askofcondition.param/intent that describe the ask or add a new var like matches.askofcondition
                                                            - or in case $$xxx:> of std matcher we add it into the provided var where the entity status is described
                                            , or
                                        - matcher ( std matcher , case $$$$'jscodeEvent') can run a js code that returns true/false to manage condition match result ( condition test a boolean entity tre/false , a Event) but
                                            the Event code  will start process a targhet entity/intent set by jscode  in a entity var, usually attach to askmatches itself . the entity will be processed by following turns till succedeed or rejected

                                        - The entity/intent  content, can be  
                                            - its name/key  +  short descr or voice name ( a scalar entity ofen stored in plain attributes of a obj )
                                              or 
                                            - its property/relation  ( bl fields ) + its definition model to match ( cursor) ( a obj entity ofen stored in
                                                    - a map ent/int={ent1:item1,,, )
                                                    - a querymap ent/int=[{name,val},,,]
                                         - The entity/intent  can
                                            - ASSK be resolved and merged with the condition itself so the condition can set the entity result in .matches and  can root to next action if matched ,
                                                or
                                            - is/can (by a intent resolver child) be a target int/ent processed partially and set its status in a proper var , 
                                                    often embedded in askmatches in a property like params or intent because so can be added in 
                                                the ask is dedicated to manage the entity so we attach the entity to it
                                                following the next turn will process the target entity till be resolved/rejected   
                                                for example a intent can be processed progressively in a intent resolver child or in one shot by a agent so anyway we choose a std way to set its var in a separate entity var and not in a 
                                                        entity tied on a condition ! 
                                        - when a matcher returns the result, according its api, is processed by addMatcRes(mat,storemat/storeVal='matched obj/objname',param=askmatches.obj) that 
                                                set the status of the entity
                                                * 
                                                * to fill the condition models: matchers ...  and its targhet askmatches .... according with its type
                                                    ex: $$dyn_medicine:>  is a fw special matcher targeting target to dyn_medicine
                                                        $$$$ someaskmatchers=service.process a match typeapi
                                        */
                                        // get the matcher named 'matcher' in this._vcontroller.fwCb.askS . usually can use matcher='dynMatch'
                                        // associate each matcher with a matchtyp according with registration , TODO 
                                        let matchTyp,// better use mnemonics like const DYNMATCH=0,,,,,
                                        mT;// the matching type to set in obj result can be  Ent/Int/Cur
                                        if(matcher=='dynMatch')matchTyp=0;// entity match
                                        else  if(matcher=='intMatch')matchTyp=1;// intent match
                                        else  if(matcher=='dynQuery')matchTyp=2;// query match

                                                        let tomatch_=tomatch;// the input of not std matchers 
                                        if(state.dir){// changes the text to match with service; nb seems too  :  state.dir = session.dir 
                                            if(state.dir.cond[entity]&&state.dir.cond[entity].term){// the var to take as input , ex ''vars.result' x user text 
                                                let term=looseJsonParse(null, step.values, step,state.dir.cond[entity].term,null,null,previous.channelData);// test with looseJsonParse(null, step.values, 'vars.result',null,null);
                                                if(term)
                                                tomatch_=term;
                                            }
                                        }    
                                            // **** result storemat MUST extend a std model + type field to be managed by addMatcRes() !!!
                                            // storemat={value,type,descr,,,,+blfields}







                                        if(matchTyp==0){/* > ENTITY MATCH MATCHER case (matchTyp=0): service[matcher](=dynMatch()) must meet ASWQ entity matcher interface : see dynMatch() :
                                                        //  service[matcher=dynMatch]()  interface : return true or false (process correctly) then cb with val={matched,,,,,,rows:[{value:,,},,,]} or val={matched,,,,,,rows:{value:,,}}
  
                                                             service[matcher]=dynMatch (tomatch_,this.id,previous.collect.key,entity,step,cb)
                                                                         after calc form and url param from directives .dir and .excel 
                                                                         - form={entity,term,wheres,meta,whMmeta};
                                                                         - url=...;// is a condition directive :is extracted from step.  url will define the service to call and some param using querystring


                                                                        if  url=service://dbmatch  :   calls run_jrest(url,form,isGET)

                                                                                                                calls  plugins.dbs.restAdapter2Mongodb_(form)
                                                                                                                        // must return :
                                                                                                                < return {reason,rows:[{std+blfields},,,]}  ,  or   {reason,rows:{std+blfields}}
                                                                                                        matched=true;  
                                                                                                        < return val=mr={reason,rows={matched,,,,rows=[{},]}} 
                                                                                                        


                                                                        if  url=http://....  TODO   :   calls run_rest(url, form, method,head) 
                                                                                                        so route to a http get/post with form data/ qs calculated from frmObj
                                                                                                            nb without passing to run_jrest , so using different interface
                                                                                                                // http end point must return :
                                                                                                        < response=val=mr={reason,rows={matched,(other meta),,,rows={}}}




                                                               < will cb(val)    (async return) 



                                                            nb    jrest EMBED internal rest engine rows  with minimum meta (= matched)as requested by Entity Matcher 

                                                        */

                                            
                                            // *** dynMatch() helper must  respond according with ASWQ entity matcher interface : see dynMatch()

                                            mT='Ent';

                                            if(state.dir){// state.dir.asks.....  must have been declared as directive !  , the matcher directive  , usually set in macro condition , must have an entry in 


                                            // nb are there differences beetween    step.values.excel.direc[previous.collect.key] and  state.dir.asks[previous.collect.key]  , are they congruent/copied ??
 
 
                                            // nb we have alredy pattArray = step.values.excel[entity].model
                                           // async
                                            let matchIn,matched_=false,res=null // a obj , x example :{match,rows:[[vmatch,id,rowspatt,shortD,bldata1,bldata2,,,],,],type='dynEnt/dynCursor,,,,,}


                                            // >>>>>>   FIRE Request to service calling a service Helper x this matcher type TKK47
                                            //          the helper will return val={reason,rows:{metainfo(intentdata),
                                            //                                                   rows=result:{myrow}or[{queryrow}]}
                                            //          using the result get by a service  that MUST meet  ASWQ entity matcher interface : see fromat_v3.txt
                                            //                                          so mainly myrow or queryrow in std format 

                                            if(this._vcontroller.fwCb.askS[matcher]){// ASWQ entity matcher interface.  TODO test this way 
                                              // old run without set service context :  matchIn=this._vcontroller.fwCb.askS[matcher];
                                              console.log('convo.onstep, condition matching debug : matcher got in session.dir, type Ent, so try matching entity ',entity,' with Ent API excel matcher ',matcher);
                                              // run with context this._vcontroller.service ???????
                                              matched_=yield this._vcontroller.fwCb.askS[matcher].call(this._vcontroller.service,tomatch_,this.id,previous.collect.key,entity,step,(val)=>{res=val[0];});// a cb to set vars in template js code .general int , returns a match obj , see dynMatch in onchange.js
 
                                            }
                                            else if(this._vcontroller.service[matcher]){// ASWQ entity matcher interface. best way 
                                                // matchIn=this._vcontroller.service[matcher];
                                                //  matched_=await // on *function you yeld not await !!!! 
                                                // run matcher on its service context this
                                                console.log('convo.onstep, condition matching debug : matcher got in session.dir, type Ent, so try matching entity ',entity,' with   service ',matcher,' with Ent API:   ',
                                                matcher,'\n (text,id,key,entity,cb([{_doc:result}||result,,]||{_doc:result}||result)), result should be cursor in std format or  ASWQ entity matcher interface , returns :true/false ');

                                             matched_=yield this._vcontroller.service[matcher](tomatch_,this.id,previous.collect.key,entity,step,

                                                (val)=>{// callback,  the helper that call service will cal this cb so i can set the results of service procedure ,
                                                    // infact the return  is just the success of of the service procedure
                                                    //  service returns :   [arow1,arow2,,] or arow in the format required by this matcher type ( so intent/entity/query/atomic, see formatx.txt )
                                                    // val={meta,rows};  , meta= see format_x.txt 
                                                    //  if  rows.rows is a array :take first , so 
                                                    // val={matched,,,,,,rows:{value:,,}}

                                                // >>>>>>>    CHECK  format TKK47 , take first query array item if many rows 

                                                if(val&&val.rows){// a entity anyway if not void is selected , take first item as selected entity 

                                                    if(!val.instance){// set it 
                                                        if(Array.isArray(val.rows))val.instance=val.rows[0];else val.instance=val.rows;
                                                    }
                                                    if(val.rows)res=val;
                                                    // old :
                                                    // if(res&&res._doc)res=res._doc;// ???????????  if a db mongo query better take row._doc as row . take that as  db cursor fields
                                                    // >>>>>>>>>>><   a row=val.rows.rows  should be a std format : {value,patt,data,descr,+bl } so at least value ( is the voice name ) and patt
                                                    // so as in case of static match we will fill the matchers[entity] looking for item description in excel ( )
                                                    //  ........................................
                                                    
                                                }
                                                    if(res){
                                                // do in res.matched='match';

                                                    // ============================  app case (do a specific matchTyp ? )
                                                    //                              (pass cond as param ?)

                                                    if(state.dir&&state.dir.cond&&state.dir.cond[entity]&&state.dir.cond[entity].url.substring(0,3=='app'))

                                                    /* condition format :
                                                            {
                                                            "pattern": "oper",
                                                            "type": "regex",
                                                            "action": "execute_script", xx
                                                            "execute": {
                                                                "script": "hello",      xx  
                                                                "thread": "default"     xx
                                                            }
                                                            }

                                                    */
                                                    // pass action to redirect so update xx
                                                    res.cond=condition;
                                                        }
                                                    //=============================== 


                                            });// a cb to set vars in template js code .general int , returns a match obj , see dynMatch in onchange.js
                                            }else;//  matched=false , dont match 

                                            // useless if(matchIn){// see comment in 
                                                // start GHTR  

                                            
                                           // out int : + std dialogflow like  intent format, like askmatches :
                                            // nb notmatched prompt default is in state.dir.asks[previous.collect.key].cond[entity].notMatPr
                                            // so you can overwrite that
                                           // state.dir.asks[previous.collect.key].cond[entity].notMatPr=matched_.nmp;

                                            if(matched_&&res){ //  res meets ASWQ entity matcher interface 

                                                // >>>>>>>   FILLS META or complete  meta x the entity match , so 
                                                //              name, matched,matchertype type,
                                                if (linematch) path = condition;// do not route if is $%

                                                // store the RESULT (Management)
                                                // the dyn result can be ( depend from TYPE of the condition )
                                                //      - a ask query cursor ,                          > store in askmatches structure 
                                                //      - ask testing a intent resolution        > askmatches structure set in way like a dynquery are storen in a onchange 
                                                //      - or a simple model match               > matches structure     set in way like a intent are storen in a onchange 
                                                // if the turn will not change we cn store the result in the same ask , otherwise a child will manage the turns needed

                                                // HERE ARE CODED THE TYPE macro entity match !!!!!


                                                    // here the item matched cols is a like a static model item as in excel definition , so have value, patt, descr and some bl fileds 
                                                    // IF they will be used after we can store the match item fields in xcel as a model matched item

                                                    // if the result is a master row or a intent it will be attached to the ask in askmatches structure and used by following conditions WITH THE SAME user text ( TURM)
                                                    // in case the rest call do not change the TURN (usual) we can store the intent on the same ask if not alredy used  
                                                    // >> in case of a child , there can be user turns and the child resolved intent/master will be attached in a next ask askmatches !!!!!!!!!!!!!!!!!

                                                let vmatch,descr;
                                                // get surely known filed , other can be retrived in template by vars.matches:

                                                // match can be the same as vmatch

                                                // ??
                                                //let entity={}
                                                
                                                // *******   add fields so that addMatcRes() knows the type of result to insert 
                                                res.type=mT;// storemat.value must exists !!!!

                                                // do after : storematch.vmatch=storematch.match=rows[value];// NOT STRING so addMatcRes() wil set vars.matchers[entity]=storematch

                                                // extract the supporting condition model basic entity matched item: match/vmatch ( value/descr  or name/descr  or itemkey/itemdescr)
                                                // now, according to  ASWQ entity matcher interface let matcher find match/vmatch 
                                                // res.match=res.value;res.vmatch=res.descr;// BETTER do in onChange.addMatcRes() according with entity matcher case (why better in ? onChange.addMatcRes())
                                                
                                                res.matched='match';// std matcher indicator 

                                                step.values.__conf +=res;// toString() ??  // if(matched_.vmatch)step.values.__conf +=matched_.vmatch;
                                                storemat=res;// OR a object ??? 072020 matching in a not standard matcher ( static model enitity described in excel ) is a obj with .match and .type
                                                matched=matched_;// true

                                                console.log('convo.onstep, condition matching debug : service/entity matcher : ',matcher,' matched! , type Ent, entity ',entity,' result : ',storemat);

                                            }else;// matched=false 

                                            // } // END  GHTR
                                            // else;// matched=false 

                                        }

                                        }else if(matchTyp==1){// int : matchTyp controll he il matcher e' ok x intent resolver

                                        /*  service[matcher=intMatch]()  interface : return true or false (process correctly) then cb with val=mr.rows={intent:{}} see format.txt
  
                                                        service[matcher](tomatch_,this.id,previous.collect.key,entity,step,cb)  

                                                        url=...;// is a condition directive :is extracted from step.  url will define the service to call and some param using querystring:

                                                        if  url=service://  :  , example "service://plugins.ai.qea.natural" , calls 
                                                                                                run_jrest(url,form,isGET)
                                                                                                        as url=service://service.plugins.apluginctl/date?term=1 >
                                                                                                                // host = service.plugins.apluginctl
                                                                                                                // uri =service_function=date , qs ='term=1'
                                                                                                        will 
                                                                                                        - calc form param from drectives .dir and .excel 
                                                                                                        - resolve host to a plugin service > fw
                                                                                                            nb fw service is built by a interface nlpai :
                                                                                                                service.addPluginExtension('ai', nlpai);// ai interface x intent matchers. implements some ai  end point

                                                                                                                that register all embedded service external interface
                                                                                                                service.plugins.ai......
                                                                                                                    ex:  services['qea'] ['natural']=natural(active['qea']);// a service factory:
                                                                                                                                =function(){
                                                                                                                                    var answ = qea.answer1(text, wheres);// consider run a fts with where as alternative or run a on line fast lighter classification then a deeper classification to refine after

                                                                                                                                    let intent=new Intent(answ,wheres);// build intent (2 intents,one best intent and the second chance) with format x the caller ( int matcher, witai intent format + // role can pe put as wheref if is in wheres ?
                                                                                                                                    return {reason:'runned',rows:intent}; 
                                                                                                                                }

                                                                                                                                         Intent() constructor (intent=new Intent(res, wheres) ) 
                                                                                                                                        this=intent={
                                                                                                                                            intents:[{ name: res.intent, confidence: res.score,entities },,,],
                                                                                                                                            entities,
                                                                                                                                            discr:res.discr,
                                                                                                                                            cursor:{resModel: {disc0:{ 
                                                                                                                                                                patt: vv1,
                                                                                                                                                                vname: v1
                                                                                                                                                                },,,
                                                                                                                                                            }
                                                                                                                                                },
                                                                                                                                            group:{sel:{item:this.intents[0]},
                                                                                                                                            compl_ctx:{         // the model that is context to a thread to match the complete list of next turn qeaitem to chain 
                                                                                                                                                        cursor:{rows:[{value:qeaitemname,patt},,]},
                                                                                                                                                        resModel: {disc0:{ 
                                                                                                                                                                                patt: vv1,
                                                                                                                                                                                vname: v1
                                                                                                                                                                        },,,
                                                                                                                                                                }
                                                                                                                                                        },
                                                                                                                                        }


                                                                                                                 and all uses the same interface (form param and result format ) !!!!!!
                                                                                                        so : 
                                                                                                        
                                                                                                        case a 
                                                                                                        mr=await  myf(form);
                                                                                                            // myf interface must return rows in expected format 

                                                                                                        < return mr = {reason:'runned',rows:await myf(form)};

                                                                                                        case b 
                                                                                                        mr_=await  myf(form);
                                                                                                            // myf interface must return rows in expected format 

                                                                                                        < return mr = {reason:'runned',rows:mr_};
                                                                                                        



                                                    mr=                                            < return mr= {reason:'runned',rows};

                                                            
                                                        if  url='https://api.wit.....'       :   this url point to a internal interface (ai.witai, is a global  interface like rest) implemented to call the ext ai service 
                                                                                                so after calc interface param (form,header auth from ai.witai) , call it , via run_jrest :

                                                                                                run_jrest(url, form, isGET, head)// url=http....

                                                                                                        as url is a http will : 

                                                                                                        run_rest(url, formObj, method,head);

                                                                                                            // ext http end point must return response in rows format :

                                                                                                        < response

                                                  mr=                                              < return {reason:'runned',rows:JSON.parse(response)};


                                                // this intent matcher require that :
                                                // val=mr.rows must be in intent format : val=mr.rows={intent:{}} see format.txt
               
                                               < will cb(val=mr.rows)    (async return) 


                                            nb    jrest EMBED internal rest engine rows  with minimum meta (= matched)as requested by Entity Matcher 

                                        */

                                                // > INTENT MATCH MATCHER case (matchTyp=1):
                                                // qui il caso e come entity model che e risolto esternamente () ma in qusto 
                                                mT='Int';
    
                                                if(state.dir){// state.dir.asks.....  must have been declared as directive !  , the matcher directive  , usually set in macro condition , must have an entry in 
    
    
                                                
    
                                                // nb are there differences beetween    step.values.excel.direc[previous.collect.key] and  state.dir.asks[previous.collect.key]  , are they congruent/copied ??
     
     
                                                // nb we have alredy pattArray = step.values.excel[entity].model pattArray={itema-regexa&itemb-regexb&.......}
                                               // async
                                                let matchIn,matched_=false,res=null // a obj , x example :{match,rows:[[vmatch,id,rowspatt,shortD,bldata1,bldata2,,,],,],type='dynEnt/dynCursor,,,,,}
    
                                                // find matcher/agent schemaurl must be in model
                                                // >>>>>>    MUST BE SAME INTERFACE AS : _vcontroller.service.dynMatch
    
                                             if(this._vcontroller.service[matcher]){
                                                    // matchIn=this._vcontroller.service[matcher];
                                                    //  matched_=await // on *function you yeld not await !!!! 
                                                    // run matcher on its service context this
                                                    console.log('convo.onstep, condition matching debug : matcher got in session.dir, type Int, so try matching intent ',entity,' with   service   ',matcher,
                                                    '\n with Ent API: (text,id,key,entity,cb(result)), result should be intent in witai std format, returns :true/false ');
                                                // like ent :matched_=yield this._vcontroller.fwCb.askS[matcher].call(this._vcontroller.service,tomatch,this.id,previous.collect.key,entity,step,(val)=>{res=val[0];});// a cb to set vars in template js code .general int , returns a match obj , see dynMatch in onchange.js
 
                                                 matched_=yield this._vcontroller.service[matcher](tomatch_,this.id,previous.collect.key,entity,step,
                                                    (val)=>{// callback the service will cal this cb so i can set the results of service procedure , infact the return  is just the success of of the service procedure
                                                    res=val;    
                                                    if(res){ // res.conf>0.5 && res.entities .....
                                                        if (linematch) path = condition;// do not route if is $%
        
                                                        // store the RESULT (Management)
                                                        // the dyn result can be ( depend from TYPE of the condition )
                                                        //      - a ask query cursor ,                          > store in askmatches structure 
                                                        //      - ask testing a intent resolution        > askmatches structure set in way like a dynquery are storen in a onchange 
                                                        //      - or a simple model match               > matches structure     set in way like a intent are storen in a onchange 
                                                        // if the turn will not change we cn store the result in the same ask , otherwise a child will manage the turns needed
        
                                                        // HERE ARE CODED THE TYPE macro entity match !!!!!
        
        
                                                            // here the item matched cols is a like a static model item as in excel definition , so have value, patt, descr and some bl fileds 
                                                            // IF they will be used after we can store the match item fields in xcel as a model matched item
        
                                                            // if the result is a master row or a intent it will be attached to the ask in askmatches structure and used by following conditions WITH THE SAME user text ( TURM)
                                                            // in case the rest call do not change the TURN (usual) we can store the intent on the same ask if not alredy used  
                                                            // >> in case of a child , there can be user turns and the child resolved intent/master will be attached in a next ask askmatches !!!!!!!!!!!!!!!!!
        
                                                        let vmatch,descr;
                                                        // get surely known filed , other can be retrived in template by vars.matches:
        
                                                        // match can be the same as vmatch
        
        
                                                          
                                                        let mm= val.intents&&    val.intents[0];                                  // assume format in formats_x.txt
                                                       // res.match=res.value;res.vmatch=res.descr;res.matched='match';// std matcher indicator 

                                                       if(mm){// there is a first intent , take first intents as default if non explicitely said not with group.sel
                                                        res.matched='match';

                                                       // del this.group={sel:{item:this.intents[0],match:this.intents[0].name}

                                                        let isSet=setDef=false,sels=undefined;


                                                        // SSRT simil to SSRG if selector is not already  set set it with first intent 
                                                            let value_,int_;
                                                           val.group = val.group || {};
                                                           if (val.group.sel) {
                                                               isSet = true;// take it value
                                                               if (val.group.sel.match) {// sel is is set , take it 
                                                                   // sels=val.group.sel.item;
                                                                   res.match = res.vmatch = val.group.sel.match;
                                                                   res.instance = val.group.sel.item;
                                                               } else {
                                                                   res.match = res.vmatch = null;
                                                               }
                                                           } else {// selection not set, assume here the first  
                                                               res.match = res.vmatch = val.intents[0].name;//// std matcher indicator x intent/entity
                                                               res.instance = val.intents[0];
                                                               if (val.intents[0].descr) res.vmatch = val.intents[0].descr;
                                                               val.group.sel = { item: res.instance, match: res.match }
                                                           }

                                                            // leave some char , ex ':' ( wit.ai entities bad name )
                                                            let lsc=true;
                                                            if(lsc){let ents={};
                                                           for(let e in val.entities){
                                                            let name=e.replace(/\$/g, "_").
                                                            replace(/:/g, "_");
                                                            ents[name]=val.entities[e];
                                                           }
                                                           val.entities=ents;
                                                            }

                                                        // add fields so that addMatcRes() knows the type of result to insert 
                                                        res.type=mT;// storemat.value must exists !!!!
                                                        // do after : storematch.vmatch=storematch.match=rows[value];// NOT STRING so addMatcRes() wil set vars.matchers[entity]=storematch
        
                                                        step.values.__conf +=res.text;// toString() ??  // if(matched_.vmatch)step.values.__conf +=matched_.vmatch;
                                                        storemat=res;// OR a object ??? 072020 matching in a not standard matcher ( static model enitity described in excel ) is a obj with .match and .type
                                                        //matched=matched_;// true
        
                                                        console.log('convo.onstep, condition matching debug : service/entity matcher : ',matcher,' matched! , type ',mT,' , entity ',entity,' result : ',storemat);
                                                    }else{
                                                        storemat={matched:null};// no match from intent ext service call result , managed by addMatRes()
                                                       // matched=matched_;// true , manage null result in addMatRes() 
                                                           
                                                    }
                                                        
        
                                                    }else{// matched=false 
                                                        storemat={matched:null};// no match from intent ext service call result , managed by addMatRes()
                                                       // matched=matched_;// true , manage null result in addMatRes() 
                                                    }
                                                });// a cb to set vars in template js code .general int , returns a match obj , see dynMatch in onchange.js
                                                matched=matched_;
                                                }else{// there is no service to call , error 
                                                    // or transmit the reason match and insert  storemat={matched:'err'};
                                                    ;
                                                }


                                                // useless if(matchIn){// see comment in 
                                                    // start GHTR  
    
                                                
                                               // out int : + std dialogflow like  intent format, like askmatches :
                                                // nb notmatched prompt default is in state.dir.asks[previous.collect.key].cond[entity].notMatPr
                                                // so you can overwrite that
                                               // state.dir.asks[previous.collect.key].cond[entity].notMatPr=matched_.nmp;
    

    
                                                // } // END  GHTR
                                                // else;// matched=false 
    
                                            }
    
                                            
                                            // ...............
                                        }else if(matchTyp==2){// query



                                                  // VERY LIKE TO a Entity matcher BUT :
                                                  //  >>>>  we must add to result model  the context needed to a thread to match a item in the rows list :
                                                  //  {,,rows(main associated model to child),cursor,group, + other model to be used in child in group or aside} 



                                                        /*  service[matcher=dynQuery]()  interface : return true or false (process correctly) then cb with val={matched,,,,,,rows:[{value:,,},,,]} or val={matched,,,,,,rows:{value:,,}}
  



                                                            service[matcher](tomatch_,this.id,previous.collect.key,entity,step,cb)
                                                                     after calc form and url param from directives .dir and .excel 
                                                                         - form={entity,term,wheres,meta,whMmeta,sel_ctx:true};
                                                                         - url=...;// is a condition directive :is extracted from step.  url will define the service to call and some param using querystring

                                                                        if  url=service://dbmatch  :   
                                                     
                                                                                                        calls run_jrest(url,form,isGET)
                                                                                                                as url=service:
                                                                                                                calls  plugins.dbs.restAdapter2Mongodb_(form)


                                                                                                                        // must return rows in std format , see format.txt:
                                                                                                                < return {reason,rows:[{
                                                                                                                                         value,patt,descr,           std nb value is like a vname (key as name that is not really important here )
                                                                                                                                        +blfields
                                                                                                                                        },,,],


                                                                                                                            }

                                                                                                        if form.sel_ctx:true , build a ctx model for a selector thread (could be done in restAdapter2Mongodb_ too )


                                                                                                                                // like qea intent add context to support  process selection in a selector thread:
                                                                                                            cursor:{resModel: {value1=rows[0].value:{ 
                                                                                                                                                                patt:rows[0].patt // a regex ? or just like vname
                                                                                                                                                                vname:vname0=rows[0].value
                                                                                                                                                                },,,
                                                                                                                                                    },
                                                                                                                                        medSyntL:[vname0,vname1,,,]// to list all items
                                                                                                                                        },
                                                                                                            group:{sel:{item:this.intents[0]}



                                                                                                        matched=true;                 
                                                                                                        < return val=mr={reason,rows={matched,,,,rows=[{},]}} 






                                                // this intent matcher require that :
                                                // val=mr.rows must be in intent format : val=mr.rows={intent:{}} see format.txt
               




                                               < will cb(val=mr.rows)    (async return) 





                                            nb    jrest EMBED internal rest engine rows  with minimum meta (= matched)as requested by Entity Matcher 

                                        */


                                        // VERY LIKE Ent matcher 


                                            mT='Query';

                                            if(state.dir){// state.dir.asks.....  must have been declared as directive !  , the matcher directive  , usually set in macro condition , must have an entry in 


                                            // nb are there differences beetween    step.values.excel.direc[previous.collect.key] and  state.dir.asks[previous.collect.key]  , are they congruent/copied ??
 
 
                                            // nb we have alredy pattArray = step.values.excel[entity].model
                                           // async
                                            let matchIn,matched_=false,res=null // a obj , x example :{match,rows:[[vmatch,id,rowspatt,shortD,bldata1,bldata2,,,],,],type='dynEnt/dynCursor,,,,,}


                                            // >>>>>>   FIRE Request to service calling a service Helper x this matcher type TKK47
                                            //          the helper will return val={reason,rows:{metainfo(intentdata),
                                            //                                                   rows=result:{myrow}or[{queryrow}]}
                                            //          using the result get by a service  that MUST meet  ASWQ entity matcher interface : see fromat_v3.txt
                                            //                                          so mainly myrow or queryrow in std format 

                                             if(this._vcontroller.service[matcher]){// ASWQ entity matcher interface. best way 
                                                // matchIn=this._vcontroller.service[matcher];
                                                //  matched_=await // on *function you yeld not await !!!! 
                                                // run matcher on its service context this
                                                console.log('convo.onstep, condition matching debug : matcher got in session.dir, type Ent, so try matching entity ',entity,' with   service ',matcher,' with Ent API:   ',
                                                matcher,'\n (text,id,key,entity,cb( [ {_doc:result}||result ,,] || {_doc:result}||result) ), result should be cursor in std format or  ASWQ entity matcher interface , returns :true/false ');




                                             matched_=yield this._vcontroller.service[matcher](tomatch_,this.id,previous.collect.key,entity,step,

                                                
                                                (val)=>{// callback,  the helper that call service will cal this cb so i can set the results of service procedure ,
                                                    // little differences from Ent matchers , here we have many rors ! 

                                                    

                                                // >>>>>>>    CHECK  format TKK47 , take first query array item if many rows 

                                                if(val&&val.rows&&val.objMod){// val.objMod  means is good model to take : must be satisfied the required val={objMod:true,matched,,,,,,rows:[{value:,,}]}
                                                    // if(Array.isArray(val.rows))val.rows=val.rows[0];
                                                    res=val;                                                    
                                                }
                                                });

                                                if(matched_&&res){ 


                                                    if (linematch) path = condition;// do not route if is $%

                                                    let vmatch,descr;
                                                    // get surely known filed , other can be retrived in template by vars.matches:
    
                                                    // match can be the same as vmatch
    
                                                    // 
                                                    //let entity={}
                                                    
                                                    // *******   add fields so that addMatcRes() knows the type of result to insert 
                                                    res.type=mT;// storemat.value must exists !!!!
   
                                                    res.matched=res.matched||'match';// std matcher indicator NBNB match as query result not as selection  !! ( must see .group.sel.item/instance !!!)
                                                                                    // if selection was done we set .match 



                                                        // SSRG simil to SSRT if selector is not already  set set it with first intent 
                                                        let val=res;
                                                        val.group = val.group || {};

                                                    if(!res.match){// only if match is not already set we fill depending on .group.sel  
                                                        if (val.group.sel) {
                                                           // isSet = true;// only if a selection is done take that value as match . no default set !
                                                            if (val.group.sel.item) {// sel is is set , take it OR sel.matched
                                                                // sels=val.group.sel.item;
                                                                res.match = val.group.sel.item.value;
                                                                
                                                                res.instance = val.group.sel.item;
                                                                if(res.instance)res.vmatch=res.instance.vmatch||res.instance.descr||res.vmatch;
                                                            } else {
                                                                res.match = res.vmatch = null;
                                                            }


                                                        } else {
                                                            // selection not set, assume here the first  

                                                                /* NO do not set any def ! 
                                                            res.match = res.vmatch = val.rows[0].value;// val.intents[0].name;//// std matcher indicator x intent/entity
                                                            res.instance = val.rows[0];
                                                            if (val.rows[0].descr) res.vmatch = val.rows[0].descr;
                                                            val.group.sel = { item: res.instance, match: res.match }
                                                            */

                                                        }
                                                    }
    
                                                    // ?? step.values.__conf +=res;// toString() ??  // if(matched_.vmatch)step.values.__conf +=matched_.vmatch;
                                                    storemat=res;// OR a object ??? 072020 matching in a not standard matcher ( static model enitity described in excel ) is a obj with .match and .type
                                                    matched=matched_;// true
    
                                                    console.log('convo.onstep, condition matching debug : service/entity matcher : ',matcher,' matched! , type Query, entity ',entity,' result : ',storemat);
    
                                                    
    
                                                }else;// matched=false 

                                    

                                    }
                                }
                            }

                                    }// a not std matcher ends
                                

                                        /* 
                                        function addMatcRes(mat,entity,storemat){// register last turn match asked with $$ or $% result 
                                            // mat      : true if entity is matched
                                            // entity   : model name ($$ case) otherwise condition  index 
                                            // storemat : matched item value 
            
                                            // so matches can be available in out as step=this ,this.values.askmatches[thisaskmatchesname].match/nomatch='entity1|entity2'
                                            let mf;
                                            if(mat)mf='match';else mf='nomatch';
            
                                            // register only model matches : 
                                            if(mat)step.values.matches[entity] = storemat;// register under values.matches.entity=itemvalue
             
                                            step.values.askmatches[previous.collect.key]=step.values.askmatches[previous.collect.key]||{match:[],nomatch:[]};
                                            // if(step.values.askmatches[previous.collect.key][mf])
                                                step.values.askmatches[previous.collect.key][mf].push({key:entity});
                                            // else step.values.askmatches[previous.collect.key][mf] = {key:entity};// first value
                                            //step.values.askmatches[previous.collect.key].match += entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                                       
                                        }*/



                                        /* mng summary : register the match/no match :
                                            - if matches register the ask matches 
                                                and the 
                                        */

                                        // ******* Register the match/no match
                                        if (matched) {

                                            // 092021 add onMatch applet in directives . cases $$ $% $$$ , + have entity only ????
                                            if((cond_type==C_$$||cond_type==C_$p||cond_type==C_$$$)&&

                                                entity&&state.dir&&state.dir.cond&&state.dir.cond[entity]&&state.dir.cond[entity].onMatch){
                                                console.error(' convo debug : onMatch directive macro run on matched model')
                                                looseJsonParse(null, step.values, step, state.dir.cond[entity].onMatch, null, null,previous.channelData);
                                            }

                                            if (storemat) {// the matched item , if there is the entity value , so in case of $$ , a model match or a integer/string got (itemname=value)
                                                /*
                                                step.values.matches[entity] = storemat;// register under values.matches.entity
                                                step.values.askmatches[previous.collect.key]=step.values.askmatches[previous.collect.key]||{};
                                                if(step.values.askmatches[previous.collect.key].match)step.values.askmatches[previous.collect.key].match='|'+entity;
                                                else step.values.askmatches[previous.collect.key].match = entity;
                                                //step.values.askmatches[previous.collect.key].match += entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                                                */

                                                let ssm=matcher==null;// stdStaticmodel with regex model
                                                // if(prevMat);// if there was a previous match to check and matches:  rebuild matching status , as was matched from new
                                                if (chmatch) {// xy§ ex $$§ : also here do routing to new match also if was the same as before
                                                    if (linematch) path = condition;// do not route if is $%  0503
                                                    addMatcRes(true, entity, storemat, ii, linematch, rematch, null, param, storeVal,ssm);// rebuild anyway

                                                }
                                               else addMatcRes(true, entity, storemat, ii, linematch, rematch, null, param, storeVal,ssm,pattArray);// linematch means to route on this condition , if maches
                                            } else addMatcRes(false, entity, null, ii, linematch);
                                        } else {// not matched
                                            if (prevMat) {
                                                // if there was a previous match to check leave the previous matching status , but do not consider matched now this condition
                                                console.log('  check MATCH: no new match so just leave previous match status,  at step index ', step.index, ' condition : ', condition);
                                                // if chmatch store previous, if exists and we dont match current restore past match
                                                step.values.matches[entity] = prevMat;//  restore previous, do nothing
                                            }
                                            else //addMatcRes(false, entity, null, ii, linematch);
                                            addMatcRes(false, entity, null, ii, linematch, rematch, null, param, null,null,pattArray);//24112020 added def in desire selection with :>
                                                                                                // in case of $$desire:>return , param is not void , so :
                                                                                                //   if dont match , anyway set the return model to default desire  item (??? to review!), we can see if is really matched for example looking at matched

                                        }
                                         // ******* ends Register the match/no match

                                    }// end  if didnt match do it

                                    if (linematch && matched) break;// dont break in $% case (linematch is false). break condition loop  for (p= ....)

                                }// end $x case can be $$

                            } // end $xy cases (also $$$x cases )

                            else {// no $$$... , no $$... ,no $%.. case, so regula std string or regex condition testing
                               cond_type=C_def;
                                patt = condition.pattern;

                                //test = new RegExp(patt, 'i');

                                // TODO: Allow functions to be passed in as patterns
                                // ie async(test) => Promise<boolean>
                                if (!notest && ttest(tomatch, patt)) {// no model, just test tomatch (text or a var) against patt
                                    console.log('\n    >>   MATCH Detected : regex condition matched  at ask: ',previous.collect.key,' (step index ', step.index, ') condition : ', condition);
                                    /*if (storemat) {
                                        step.values.matches[entity] = storemat;// register under values.matches.entity

                                        step.values.askmatches[previous.collect.key].match = entity;// += '|'+entity in case of multimatch. register too the step was  matched in favor of entity 
                                    }*/

                                    addMatcRes(true, null, null, p, true,true);// if a condition with no model matches we register a match {ind:4} and not {key:value}


                                    path = condition;
                                    break;// break p index
                                }else console.log('\n    >>   NO MATCH or cant matching : string condition ( number ',p,'), step index ', step.index,', condition : ', condition);

                            }// end no $$$ , no $$ ,no $% case
                        }// end hyt
        // ******* model matching section ends 

                            // 012021 TODO : potrei passare come controlling filter il che nelle posizioni voute skippa i match perche filtered out 

                        function stdMatch(tomatch,pArray,pattArray,linematch,step,entity,medSync){//  a std matcher regex
                            // from pArray ( the pattArray format in case $$aaskquery:> )or    
                            //  pattArray the static regex entity in excel or online , 
                            // medSync is its filtering array , do not test if item void 
                            //   nb  medSync[] contains the key  of pArray , describing the match/selectionpattern data, to select item i, or null if is filtered ( not matchable) 
                            // taking care of linematch (// do not route if is $%)
                            // calc :return   {matched,path,storeVal,notest,storemat,storeMId:ii};// storemat and storeMId the item and index matched on pArray/pattArray


                            let storemat,patt,rematch,//the matching val
                            ii=0,// matching index or filterindex
                            storeVal,notest=false,matched=false;

                            // can run ONLY in text result/tomatch ( no run if returning from a child !!!)
                            if(typeof tomatch !== 'string' && !(tomatch instanceof String))return {matched,path,storeVal,notest,storemat};
                            let  itr1;// itr1= array of itemName  or the pattArray.split(itemSep); .     ??when 0 stop while

                        /* no good :
                        // pattern description x regex entity
                        // base format pattArray={itema-regexa&itemb-regexb&.......}
                        // if firse 4 char is : {xy}, take x instead of - and y instead of &
                        let itemSep='&',nameSep='-';
                        if(pattArray.length>7&&pattArray.charAt(0)=='{'&&pattArray.charAt(3)=='}'){// set x,y
                            itemSep=pattArray.charAt(2);nameSep=pattArray.charAt(1);
                            pattArray=pattArray.substring(4);
                        }

                        if(pArray)itr1=Object.getOwnPropertyNames(pArray);
                        else {
                            // TODO TODO todo : do the same on mod_feature branch
                            if(pattArray.length>7&&pattArray.charAt(0)=='{'&&pattArray.charAt(3)=='}'){// set x,y
                                itemSep=pattArray.charAt(2);nameSep=pattArray.charAt(1);
                                pattArray=pattArray.substring(4);
                            }
                            itr1=pattArray.split(itemSep);
                        }
                        for(ii=0;ii<itr1.length;ii++){// gh for all item in model test it 


                        if(pArray){
                            patt = pArray[itr1[ii]].patt;
                            storemat = itr1[ii];
                            console.log(' condition try matching : $$ case , ii: ',ii,' storemat(matched item value/name)  is  ', storemat, ' patt is : ', patt);
                        }else{
                        let sar=itr1[ii].split(nameSep);//itr1[ii].indexOf('-');
                        if (sar.length > 1) {
                            patt = sar[1];
                            storemat = sar[0];
                            console.log(' condition try matching : $$ case , ii: ',ii,' storemat(matched item value/name)  is  ', storemat, ' patt is : ', patt);

                        } else notest = true;
                        // end for 
                        }*/



                        // 072020
                        // pattern description x regex entity
                        // base format pattArray={itema-regexa&itemb-regexb&.......}
                        // if firse 4 char is : {xy}, take x instead of - and y instead of & example when we put regex as pattern better use as delimiters  
                        let nameSep='-',// no good so when there is regex use {£&} after $$model:... , so $$model:{£&}......
                        itemSep='&';



                        
                            if (pArray)// ( the pattArray format in case $$aaskquery:> )
                             itr1 = Object.getOwnPropertyNames(pArray);// here array of itemname 
                            else {
                                // TODO TODO todo : do the same on mod_feature branch
                                if(pattArray.length>6&&pattArray.charAt(0)=='{'&&pattArray.charAt(3)=='}'){// set x,y : the separator 
                                    itemSep=pattArray.charAt(2);nameSep=pattArray.charAt(1);
                                    pattArray=pattArray.substring(4);
                                }
                                itr1=pattArray.split(itemSep);
                            }

                            if( itr1.length>0){// itr1= array containing  itemName (warning : different format for pArray or pattArray ! )  , really voice name 

                                let fe, gr=1,// regex group
                                freg,doL=false,fout,// § case : fout = filter out, only the filteroutput,the relevant entity content, will be matched against the model
                                ahocorasick=false,score=[];
                                // when extract some regex group number X use a filter starting the declaration with : model:§Xregexgroup1_filter§firstitemname-.............
                                // then if first item name is 'value' i will fill the value with filter output , otherwise we do match items usually with its pattern but against the filter output not user utterance
                                if(itr1[0].charAt(0)=='§'){// case : MATCH a GROUP MATCH gr  in value item , set item and patt separator in case of pattArray format 
                                     if((fe=itr1[0].indexOf('§',2))>0){
                                         let fc=itr1[0].charAt(1),sf=1;
                                        if(fc>='0'&&fc<='9'){gr=fc-'0';sf=2;}
                                         let freg=itr1[0].substring(sf,fe);// mod:§2myregexfilt§value-x    freg='myregexfilt'
                                         itr1[0]=itr1[0].substring(fe+1);// through away filter info 
                                        let fm= ttest(tomatch, freg);
                                       if(fm&&Array.isArray(fm)&&fm.length >= gr && Boolean(fm[gr]))
                                            {doL=true;tomatch=fout=fm[gr];// take group gr as result , thats the filtered input that will be used to match the model
                                                console.log(' stdMatch § case: matching text is filtered by regex GROUP before matching items, group  condition try matching : $xmodel:§zR§inlinemodeldeclaration case recognized, inlinemodeldeclaration model will be tested on regex R, group z, match: ',tomatch,
                                                ' please call value the first item to load full filtered text (regex group n ',gr,') ');}
                                    }}else doL=true;
                                
                                   // if(itr1[0].charAt(0)=='@'){// case : ahocorasick , see https://github.com/BrunoRB/ahocorasick
                                   //     ahocorasick=true;itr1=itr1.substring(1);
                                    
                            let storematV=[];
                            if(doL)
                            for (ii = 0; ii < itr1.length; ii++) {  // gh for all item in model (pArray keys (itemname) array   or pattArray (array of itemname-pattern)  ) test it 
                                                                    // pArray case: in case of missing pArray[item].index we suppose the Parray keys are in sync with rows[].value=item   ?????
                                // start  condition try matching 
                                // nb value case  ex: $$mod_ent:|reexfilter|
                                //      in first item inside the || we put the filter , so the item patterns will be tested against the filter output (first matching group )

                                let itemNam=itr1[ii];// pArray : the item name ( intents[x].name  or rows[x].value )
                                                    //  pattArray : itemNam='itemname'+'-'+patt

                                let ind=-1;// pArray case , the index of associated rows[] : is normally ii , but if have sync array we check it :
                                if(pArray
                                    // &&pArray[itemNam].index can be 0 ! so false 
                                    &&!isNaN(pArray[itemNam].index)
                                    &&pArray[itemNam].index>=0){// pArray.index contain the index in rows of the item 
                                    ind=pArray[itemNam].index;// should be ii !!!
                                    if(ind != ii)console.error(' debug checking dynamic desidered $$x:> case : seems problem on sync pArray item  sequence with rows item sequence  . please check it ');
  
                                }else{
                                    ind=ii;
                                   // console.error(' dynamic desidered $$x:> case : seems problem on sync pArray item  sequence with rows item sequence  . please check it ');
                                }
                                if(!medSync||medSync[ind]){// skip filtered items if in existing medSync the  , they have medSync[ind] null

                                // TESTING from the declared entity in excel :  
                                //                                      if the entity is described in excel ( in excel every item has a name and a patt and a vname , and can have description and some bl values )
                                //                                              we test its item :
                                //                                              itemname storemat with pattern patt  
                                //                                     if the entity is described in excel just with the entity name and the algo/external REST url that will resolve
                                //                                               we call the name resolved by external algo 'value' and the resolved  matching entity ( atomic or obj ) are put in storeval

                                if (pArray) {// itemNam=theitemName
                                    patt = pArray[itemNam].patt;
                                    storemat = itemNam;// the itemname
                                    console.log(' convo.stdMatch():  condition try matching : $$ case , ii: ', ii, ' text : ',tomatch,', item (storemat) :  ', storemat, ' on patt : ', patt);
                                } else {// itemNam='itemname'+'-'+patt
                                    let sar;//=itr1[ii].split('-');//better as the regex can contains '-' , so itr1[ii].indexOf('-');
                                    //sar = itr1[ii].indexOf('-');
                                    sar = itemNam.indexOf(nameSep);
                                    if (sar >= 0 && sar < itemNam.length + 2) {// >1 2 ?

                                        storemat = itemNam.substring(0, sar);
                                        patt = itemNam.substring(sar + 1);
                                        console.log(' convo.stdMatch() :condition try matching : $$ case , ii: ', ii, ' text : ',tomatch,', item (storemat) :   ', storemat, ' on patt : ', patt);

                                    } else notest = true;
                                    // end for 
                                
                                }
                                

                                // attention : try to set best keyword match here . the first pattern in PArray or pattArray have a @ start !!
                                if(//ii==0&&
                                    typeof patt === 'string'&&patt.charAt(0)=='@'){// case : ahocorasick , see https://github.com/BrunoRB/ahocorasick
                                        ahocorasick=true;patt=patt.substring(1);}

                                // test = new RegExp(patt, 'i');


                                // TODO: Allow functions to be passed in as patterns
                                // ie async(test) => Promise<boolean>

                                // *** TRY MATCHING iesimo item in Entity Model
                                //  - value case
                                //      if the entity has only 1 item (ii=0 only), with value name , we have a number/string entity so we got it with a regex group ( named or numbered ) so we need to extract from utterance 
                                //      if we , then want to match the string with a model we can do default model matching, but without to extract the group each item 
                                //      in this case we filter before the model matching ! 
                                //      ex: $$mod_ent:|reexfilter|red-red&blu-blu     or if we take the value of filter out : $$mod_ent:|reexfilter|value-x
                                if (!notest )
                                    if(ahocorasick){

                                        storematV.push(storemat);let sco;
                                        score.push((sco=ahocorA(tomatch, patt)));// [3,0.75] so 3 kewword match , score is 0.75 , so total kyword to matc was 3/3*4=4
                                        console.log(' ahocorasick scored usertext ',tomatch,' against patt ',patt,' matching keywords, % : ',sco);
                                    }else{// take first match 
                                    if(rematch = ttest(tomatch, patt)) {// rematch means 'match result'. match if ttest returns a not null rematch. rematch[1]>matches.entity.
                                    // ok : 
                                    console.log(' \n    >>   MATCH Detected  . convo.stdMatch() : on MODEL ', entity, ' with $$ or $% condition, at thread ', thread_name, ',step ', step.index, ' ,previous ask:key ', previous.collect.key, ' , condition index ', p, '\n  matched item : ', storemat, ', index : ', ii, ', regex group extracts: ', rematch);
                                    step.values.__conf = step.values.__conf || '';// confirm  the user matched something 
                                    //if(data !== null && data !== ''  && data!==undefined) {}  You can use below simple code
                                    // if(Boolean(value)){ 

                                // NBNB TODO TODO   012021
                                    // this case can collide when we want to get a entity with a rest matcher of type entity . in this case we call the item value to say what field of entity load as the item value 
                                    // so if we want to load a number with a regex group is better to call item $ or $value or $regex .... ????????????????????


                                    if(ii==0&&storemat == 'value'){// if the first itemname is 'value' : fills this item with regex group : storeVal = matching group
                                    if (!fout){// value item with no § case (std user text match). set the regex first group as item matched 
                                        if(// fill value with old way
                                         Array.isArray(rematch)&&rematch.length > 1 && Boolean(rematch[1])) {// manage a value :the 'item name' is 'value' , it assumes the matched val that must be first group

                                        //    if(rematch[1]){
                                         storeVal = rematch[1];
                                       console.log(' \n  convo.stdMatch() : as the first entity item name is value: set as match the first matching  group ',storeVal);
                                        // step.values.excel[entity].vmatches.value;// is not used 
                                        step.values.__conf += storeVal;
                                        matched = true; // break ii loop, (loop: in a $xy condition for all item in model test it )
                                         //}else break;// anyway

                                        } else {// dont match , match value is =null/''
                                            // storeVal = null;// useless
                                            }// anyway break but not match if the group in a void string 
                                    }
                                    else{// § case, fout : new filter and get value impl.
                                        storeVal = fout;//=tomatch
                                        step.values.__conf += storeVal;   
                                        matched = true; // break ii loop, (loop: in a $xy condition for all item in model test it )                                     
                                    }
                                    
                                    
                                }else {// manage a entity item name : recover the vname from excel model 
                                        storeVal = null;
                                        // recover vmatch if present on model
                                        if (step.values.excel&&step.values.excel[entity] && step.values.excel[entity].vmatches) step.values.__conf += step.values.excel[entity].vmatches[storemat];// get voice entity name from excel
                                        else step.values.__conf += storemat;
                                        matched = true; // break ii loop, (loop: in a $xy condition for all item in model test it )
                                    }

                                    if (linematch) path = condition;// do not route if is $%
                                    /* put in addMatcRes :
                                    if(mydyn){// a cursor selection case ii is the matched index 
                                            mydyn.param.group.sel=step.values.askmatches[desiredE].cursor.data[ii];
                                            //todocheckvname vmatches; now we can find in data[][]=mydyn.param.group.sel[12];
                                            //=mydyn.param.group.sel[12];

                                    }*/
                                    // set before : matched = true; 
                                    break;// break ii loop, (loop: in a $xy condition for all item in model test it )
                                }
                                } // ends match detected 

                                else {// 
                                    //  addMatcRes(false,entity);
                                }

                            }else{
                                console.log(' skip test on item of index ',ii);// is filtered by medSync
                            }
                            }//  end ii for , test item in model  .   end condition try matching. gh  

                            if(ahocorasick){// choose the max keyword not duplicated found 
                                let mscor,mind,ms=0,scored;
                                score.forEach((el,ind) => {//score was : [    [ [ 19, [ 'keyword1' ] ],     [ 47, [ 'keyword2' ] ] ],    ,,,,]
                                                            // now is [ [keyword matches , % of keywords matched] ,,,,  ]
                                                            console.log(' scoring item: ',el,' index: ',ind);
                                    if(ms<el[0]){//this item has keywords matches are more than current max, so get it as parial max
                                        ms=el[0];mscor=[];mind=[];mscor.push(el);mind.push(ind);
                                    }else if(ms>0&&ms==el[0]){
                                        mscor.push(el);mind.push(ind);// register this item in list of items having mas matches 
                                    }
                                });
                                let iy=-1;
                                if(mscor){
                                if(mscor.length>1){// there are more than 1 item having max matches . leave common ,undiscriminant?
                                    console.log(' there are more than 1 item having max matches, mscor[0] ',mscor[0],' , mscor[1] ',mscor[1]);
                                   if(mscor[0][1]<mscor[1][1]){iy=mind[1];
                                    scored=mscor[1][1];
                                    }else {iy=mind[0];// first ??? or find item with best score among first 2 
                                        scored=mscor[0][1];
                                    }
                                }else{
                                    iy=mind[0]; scored=mscor[0][1];// iy is the item index (0,1,2,....)
                                }
                                }

                                if(iy>=0){
                                storemat=storematV[iy]; // best match item name/key
                                  // ok : 
                                  console.log(' \n    >>   MATCH Detected  . convo.stdMatch(): best keyword match (score: ',scored,' on MODEL ', entity, ' with $$ or $% condition, at thread ',
                                  thread_name, ',step ', step.index, ' ,previous ask:key ', previous.collect.key, ' , condition index ', p, '\n  matched item : ', storemat, ', index : ', iy);
                                  step.values.__conf = step.values.__conf || '';// confirm  the user matched something 
                                  storeVal = null;
                                  // recover vmatch if present on model
                                  if (step.values.excel&&step.values.excel[entity] && step.values.excel[entity].vmatches) step.values.__conf += step.values.excel[entity].vmatches[storemat];// get voice entity name from excel
                                  else step.values.__conf += storemat;
                              if (linematch) path = condition;// do not route if is $%

                              matched = true; 
                              ii=iy;// to eventually set  storeMId
                                }else console.log(' \n   >>   NO MATCH Detected  . convo.stdMatch(): best keyword dont match on MODEL ', entity);

                            }

                            }
                                                  
                            // in case of pArray check if the array is tied to a filtered subset of its associated rows, in this case take ii s the index of the mapped rows 
                            let storeMId;
                            // the index in case of static definition is the index of the definition array (pattArray)
                            // BUT in case we do dinamic match in cursor rows we use a dynamic definition pArray THAT CAM BE A FILTERED VERSION if the full rows 
                            //      >> in this case the pArray must have th eindex property to address the item in rows !!! pAttay.index 
                            // NO if(pArray&&pArray.mapInd)storeMId=pArray.mapInd;else storeMId=ii;// see : 012021 ripresa $$desidered:>pippo in master_df_builder ....
                            if(pArray&&pArray.index)storeMId=pArray.index;else storeMId=ii;
                            return {matched,path,storeVal,notest,storemat,storeMId};// avoid use storeMId 
                        }// ends function  stdMatch()
                    
                            // STARTING MOOVING FUNCTIONS ON vCtl :
                            // put on top of this function let addMatcRes=this._vcontroller.vfwF.addMatcRes;
                            function addMatcRes(mat,// true : matched
                                entity,
                                storemat, // a string for simple static model match , a obj if we matched a entity , intent , or a query result 
                                        // storematch='thematchedvalue'
                                        // storematch={type:'Ent'/'Int'/'Cur',.....}
                                
                                // WARNING pay attention that the model name can be called in different condition also with a different inline matching definition
                                // so in this case we must known which model definition we applyed when , here, registerd the match  !!!!
                                storeMId // storemat isthe value/name matched,  storeMId is the index p 
                                ,routing// routing=linematch is true if not $% case ( not routing case ) so this condition will stop the cond loop
                                ,rematch// the regex matched extraction (....)
                                ,reset// reset matches ???? never called !!!!!!!!!!!!!!!
                                ,param,// not nul if this is a resolver selection ask
                                storeVal,// a integer or string to get from user 
                                ssm,// seems no more never used 
                                pattArray
                                ){
                                    addMatcRes_(mat,// true : matched
                                        entity,storemat,storeMId // storemat isthe value/name matched,  storeMId is the index p 
                                        ,routing// routing=linematch is true if not $% case ( not routing case ) so this condition will stop the cond loop
                                        ,rematch// the regex matched extraction (....)
                                        ,reset// reset matches ???? never called !!!!!!!!!!!!!!!
                                        ,param,// not nul if this is a resolver selection ask
                                        storeVal// a integer or string to get from user 
                                        ,step,previous,
                                        pattArray// to use info in model to set the dyn entity status
                                        )

                                }

//////////////////////////////////////////    put in onchange !!!!!

                                    // function addMatcRes() was moved to onChange() 

//////////////////////////////////////////    end put in onchange !!!!!


                            function chkMatcRes(entity){// check if model entity matched, usefull in $$ and  $%  
                                // entity   : model name ($$ case) otherwise null condition  index 
                                // returns matched model item name/value ($$ case), otherwise null

                                // debug 
                                if(!step.values.matches) console.error('  ERR   chkMatcRes cant find values.matches !!! on entity  ', entity);
                                else 


                                //if(entity)if(step.values.matches[entity]&&step.values.matches[entity].match) {// register under values.matches.entity=itemvalue
                                if(entity)if(step.values.matches[entity]) {// register under values.matches.entity=itemvalue
                                    // 022021 new rules : a model is unmatched if match is null but also ifhas param or intent matches must not be 'match
                                    //      infact a query model can be filled if matches='match' , nd match is null because not alredy selected !! 
                                    let match_=false;
                                    if(step.values.matches[entity].param||step.values.matches[entity].intent){
                                        if(step.values.matches[entity].matched=='match')match_=true;
                                    }else if(step.values.matches[entity].match)match_=true;
                                    if(match_){

                                    if(lv>3)console.log(3,'chkMatcRes : (testing a condition $xyEntity )the Entity: ' , entity,' already matched item: ', step.values.matches[entity]);
                                    return step.values.matches[entity];
                                    }

                                }
                                return null;
                            }




                        }// ends  not string pattern (REGEX_MACRO) 

                    }// end CONDITION SCAN
                    // take default path if one is set

                    // ****************  step.msgSent null ??????????????????????
                    console.log('\n\n  *** FINISHED MATCHING CONDITION ON key: ' , previous.collect.key,' at thread ', thread_name,', cmd : ',dc.activeDialog.id,' cond number: ',p,'       ****  MATCH = ', path != null,' ( action : ',(path||{action:''}).action,
                    ')\n  at previous index ', index-1,', on user answere :',step.result,' to prompt  at index :', step.msgSent,' that was  issued at a step before : ', step.msgSent<index-1, ' \n  condition matched :  ' , path, ' , default_path=   ', default_path);
                    if(path)// && path.action!='continue')
                        {winston.info('  *** NAVIGATION MATCH ON key: ' + previous.collect.key+' at thread '+ thread_name+', cmd : '+dc.activeDialog.id+' cond number: '+p+'   MATCHED'+ path +' action : '+path.action);
                    }
            // a good point to stop watching

                    // run onChangeAfterCondition Matchers  handlers
                    // usually dont change route, just calc dyn that is available after condition testing matches
                    // let index/curIndex=step.index ;// already done before 
                    let onChangeAfter=false;// when is true ???  , do we have to run also the normal onchange ( but is the same ?!!)
                    if(onChangeAfter){
                    yield this.runOnChange(previous.collect.key, step.result, dc, step);// can set askmatches[previous.collect.key].param and .complete
                    //console.log(' +++++++++++ thread ',thread_name,', step ,',index,' is testing user answere on previous ask  ',previous.collect.key,' , onchange runned and  now vars is :\n ',step.values);
                    // did we just change threads ? if so, restart this turn
                    // if (curIndex !== step.index || thread_name !== step.thread) {
                    if (index !== step.index || thread_name !== step.thread) {
                        return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                    }}





                    if (!path) {// start !PATH , previous  conditions dont matched

                        console.log(' >>>> so  at step of index  ',index,' the  previous step conditions against result , dont matched,  the user result answered to a msg (template) sent by a passed ask (before the previous) : ', step.msgSent < step.index - 1);// sent if msgSent=1 index=2, msgSent=1 index=3
                        console.log(' infact the ask that emitted the template/msg was at virtual index (step.msgSent): ', step.msgSent );
                        // no :  better after this {}, so anywhere both match or not match , if next (continue) 
                        // >>> A case : se non ho un match condition col msg previous we mast sent the msg prompt

                        // >>> todo  if(step.msgSent means msgSent is set ???
                        //  AND add a flag to decide if do or not do the retry

                        // recover excel directive x this step ask 


                        /* TODO  TODO now askmatches are in .direc. !!!!!

                        if (step.values.excel && step.values.excel[previous.collect.key]
                            && !step.values.excel[previous.collect.key].goon) goonDir = false;
                            */
                           if (step.values.direc &&step.values.direc[previous.collect.key] && step.values.direc[previous.collect.key].loopDir
                            && step.values.direc[previous.collect.key].loopDir.goon==false) goonDir = false;

                        // if (goonDir && default_path.action == 'next' && step.msgSent && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt
                        // if (goonDir && default_path.action != 'repeat' && step.msgSent && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt


			// if (goonDir && default_path.action == 'next' && step.msgSent < step.index - 1) {// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt
            //27042020
            if (goonDir && default_path.action != 'repeat' && step.msgSent < step.index - 1){// in case of defaultpath is 'continue' if dont match with old text we want also to test also this msg prompt

	/*DO GOON ( do a chance to condition to match also the previous step user answere ) Management :

    
	fase : durante il process di un step B faccio testing del  previous step A
	se , durante il testing dei condition di un previous step A su answere del msg del previous msg A o un answere precedente passato durante precedente  current process dello step A
	if a user answere massage is passed to a step ( also in index 0 , anyway will be tested as previous in next step) (result or recovering a goto passing message or begindialog )and is  :
		During the previous step testing A ( current is step+1)
		-  too old (step.msgSent < step.index - 1)   .   NBNB : if it were too old  should not  be tested conditions ????
		- conditions  didnt match or is null set
		- default set to continue ( so of is a goto we dont goto if we didnt match on a previous step answere , we also must dont match with present step answere !)


    > force default to replay ( To test condition on user answere to its proper step  msg )
    
update :

 in a previous step A we see if 


	*/

                            /*
                            console.log('  (a default apply because none of previous  condition at prevIndex ', step.index - 1, ' matched  \n  as : \n - direc[previous.collect.key].loopDir.goon==false , \n - the def condition is next/continue AND \n - we tested condition on user answer to a msg emitted before the prevIndex msg   (msg index is ', step.msgSent, ' ) \n > we retry the step at index ', step.index - 1
                                , ' coming from a reply the runstep will be called with a null result so wiil emit the previous  msg prompt'
                                + ' also gotothread will call runstep with a null result ( and index =0 )but as we find  like a gotothread  with a null result ');
                            */
                           // better and easy
                           console.log('  in previous step  ',index-1,' we tested the user answer to a prompt emitted before , but none conditions matched on ! so we need user to answere to previous msg and force REPEAT '+
                            ' \n ... so coming from a reply the next runstep will be called with a null result so wiil emit the previous   prompt !'
                           + ' also gotothread will call runstep with a null result ( and index =0 )but as we find  like a gotothread  with a null result ');
         
         
                                //path =default_path;

                            // >>>>>>>   ERROR we cant change default_path.action because will be permanent !!!!!
                            // try correct with peach RE
                            // default_path.action='repeat';

/*
                            QUESTION would be better set path=null and just goon with current handling ( so emit the msg ) insted of launch a repeat with .handleAction that returns true so exit by this convo 


*/



                            // clone values , dc.activeDialog.state different from step.state ?
                            path = Object.assign({}, dc.activeDialog.state.values);
                            path.action = 'repeat';

                            // OKOK this is a special repeat UU : msgSent dont match so ask normal step msg 
                            // normal repeat will have a no result with no goon so no msgSent will be set so current handler will emit msg prompt
                            // special repeat will have a no result with also a no  goon 

                            //  step.state.goon=step.index-3;//useless as next step will be called with result=null to issue the index-1 msg 
                            // normal repeat step.msgSent=step.index-1;

                        }

                        else path = default_path;// peach RE
                    }// ends !PATH
                    if (path) {//  start PATH   : it matches or default , !! ok

                        if (path.action !== 'wait' && previous.collect && previous.collect.multiple) {
                            // TODO: remove the final line of input
                            // since this would represent the "end" message and probably not part of the input

                        }

                        console.log(' convo after got a path executes handleAction with path :',path);
                        var res = yield this.handleAction(path, dc, step);
                        if (res !== false) {

// *******************************************************    also in all returns ?????????????????????
                        //    step.values.app=null;//19052020  without go in error : json circular structure 

                            console.log(' convo after executed handleAction  on matched previous ask condition returned not false so return ');
                            return res;
                        }
                        console.log(' convo after executed handleAction  on matched previous ask condition returned  false so goon with current handler  ');
                    }//  ends PATH
                }
            
            }
            // ****  Handle the CURRENT  step

// hotel customization 
         
           //  when receiving text (user answere put in userTurn , that can be used in onStep usually at index 0 )
           // >>>>>  better set status.userTurn in caller  dc.xxxDialog()
           // if(Object.prototype.toString.call(myVar) === "[object String]")

           // add a check from  a description flag : if(dynfield.getprevious turn on entering a new thread)
            
            /*
           console.log(', ** setting last user turn , index: ',step.index, ' result : ',step.result ,' condition ',typeof step.result === 'string',step.result instanceof String);

                if(typeof step.result === 'string' || step.result instanceof String){// register last user turn on status 
                step.state.userTurn=step.result;
                }else step.state.userTurn=null;
            */
            let recLTurn=false;// some text recoverED from previous STEP THAT CAME TO THIS THREAD FROM A BEGINDIALOG OR GOTOTHREAD,  turn status step.state.userTurn
            if(goonDir&&step.index==0



		){// in starting a new thread (after a goto) if we have some condition try to recover last user turn answere in the current cmd to test condition also with previous user answere

                // at index 0 we can have null if retrying or a beging dialog  (must not recover) or object  if coming from a goto thread (should try to recover)
   
   //             console.log(', ** this previous step of index 0, recovering last user turn : with isstringresult =',typeof step.result == 'string',' isresultNull: ',step.result ==null);//,' . String: ',!step.result instanceof String);

   console.log('\n  NOW Handling CURRENT  STEP ' , step.index ,prevName,' on thread ',step.thread,' of total ', thread.length,' steps  ');

                if(step.result !=null&&typeof step.result != 'string' ){
                    // so is obj , coming from gotothread ( also  coming from a child or resumedialog ? ), 

                    // todo verify that begindialog and replacedialog do not se step.result as a obj . we will manage that case differently 
                    //          >>>>>>>>>>>>>>>> in future we can have begindialog with string result
                    // coming from gotothread is obj , 
                    // problem both coming from begindialog(todo : change relaying the last user turn) and retry , both are null  null 
                    console.log(' **  RESULT is OBJ so RECOVERING  TEXT FROM state.userTurn, (set by jumping  GOTOTHREAD (or REPLACEDIALOG (?)) or returning from Child ,so recovered_text=state.userTurn: ',step.state.userTurn);
                    // useless : console.log(' OR this is a index 0 current handler , with obj result (so gotothread or returning from a child ( replacedialog too ???) )\n  so ( SETting recLTurn=true ) recovering last previous (before this stepindex = 0 ) user turn  text from state.userturn :',step.state.userTurn);
 
                    // now (after done previous collect match) we can change the result : 
                    if(step.state.userTurn){// do that only in goto case and userTurn is set 
                    step.result=step.state.userTurn;
                    step.state.userTurn=null;// reset ?
                    // >>>>>>>>>>>
                    // alredy set step.msgSent=0;// as came from this msg so chain next step 

                    recLTurn=true;
                    step.msgSent=-1;// added 03022020
                }
                }//else state.userTurn=null;
                else if(typeof step.result == 'string'){// is a begin dialog with string result : can forward too
                    recLTurn=true;
                    step.msgSent=-1;// added 03022020, means the user answere step.result cames from a prompt issued by a step before step 0 
                } 
                // else is null ( probably just a repeat, result is null  )
            }

            if (step.index < thread.length) {
                let line = thread[step.index];
                //console.log('convo onstep Handle the current step ,step is ' + JSON.stringify(step, null, 4) ,' text is ',step.result);



                // ******************+  step.msgSent and step.result  are undefined 

                //console.log('convo onstep Handle the current step ' + step.index ,' of ', thread.length,'steps on thread ',step.thread,' , recovered a user answere :',step.result,' to msg  of index ',step.msgSent,' ( if smaller (',recLTurn,') is a older step msg answare !) ');
               // console.log('convo onstep NOW Handle CURRENT STEP: ' , step.index ,' of ', thread.length,'steps on thread ',step.thread);
                if(step.index>0)console.log('\n continuing Handle CURRENT STEP: in this step >0 , ',prevName,', after tested  condition on previous step ',step.index-1,' with a user answere :',step.result,' to msg  of index ',step.msgSent,' ( if smaller (',recLTurn,') is a older msg then the tested condition !) ');
                else console.log('\n  continuing Handle CURRENT STEP 0 ',prevName,' a  user answer : ',step.result,' may have recovered  from a prompt issued at index ',step.msgSent, ' so to a previous prompt : si/no : ',(step.msgSent <0&&step.msgSent>-777));


                // 062019 goon trying to match more ask with a single user utterance 
                // 062021   see COR_resetmsgSent_062021 
                // if(!goOnWOColl)   // COR_resetmsgSent_062021 
                step.state.goon=null;// 
                // if(step.values.goon&&step.values.goon==true&&step.index>0)

                /*  ????
                 todo if recLTurn we can goon if there is condition to valuate !!!!!!!!!!!!
                    verify also there is a next step 
                    > are there some cond on next step ? thread[step.index+1].collect.options/key
                */
                let curkey;
                if(thread[step.index].collect&&thread[step.index].collect.key)curkey=thread[step.index].collect.key;
                if (step.values.direc && step.values.direc[curkey] && step.values.direc[curkey].loopDir) {
                    if (!(step.values.direc[curkey].loopDir.goon2_tmp==null)) {// apply just once . nb is set with : vars.direc[curkey].loopDir.goon2_tmp=false;
                        if (step.values.direc[curkey].loopDir.goon2_tmp == false)goonDir2 = false;
                        step.values.direc[curkey].loopDir.goon2_tmp=null;// reset 

                    }else if (step.values.direc[curkey].loopDir.goon2 == false) goonDir2 = false;


                }
                console.log('  NOW Handle CURRENT ,using  goonDir2: ', goonDir2 );
                if(goonDir2&&(recLTurn||step.index>0)&&(
                    step.index < (thread.length-1))&&(// cant be last
   
                    

                /*************************
                22012021  WARNING  see RREEDD 
                to match with * a continue condition ALSO with obj result ( coming from a child )
                WE TRY TO LEAVE FOLLOWING  PRECAUTIONARY CHECK :  &&(step.msgSent >-2
                */
                (step.msgSent==-777||step.msgSent >-2)&&// use results in next step if exists (msgSent=step.msgSent not null, better > -2 ) or ( added 012021 ) is a obj
                                                            // step.msgSent, >-2 means the previus message comes from the ask that goon to this th or a this th ask
                                                            // step.msgSent== -777 means the result is obj ( so is not null (step.msgSent== -1000)
                                                            // if index=0 recLTurn will decide to goon or not
                // *************************



                   // useless  ||step.msgSent>=step.index-1

		            (goOnWOColl||curkey) // and we have some condition to test also on previous user answere
                    
                    ))// if index > 0 do not send msg, it will be sent as repeat next step if dont match
                { // TTT


/*
 ***************************  GOON mng summary  ( TO review if is begindialog or resumedilog or returning after a child) 

DO GOON ( do a chance to condition to match also the previous step user answere ) if

- step with index >0 :

    if a step.result is not nulled string after onchange we test condition
    - there is some condition to test
    AND
    - the action selected was continue (so also after a check for at least one condition matched , otherwise we force a default with repeat)
    we came to manage current handler and we goto next step with present step.result  without prompting step msg for a new user answere
    
    IF  step.result is obj with index >0 ( a resume or a child return )
    after onchange we CANT do test condition 
    so ( to complte this comment )
    .........   ( seems we must do standard msg prompt to the user )
                    

    ( old comment :
	we didnd force default replay on condition 
		- a default continue   after 
        -  none condition was matched on a not null condition set 
    )

- step 0 
         we dont do any previous testing 
         when the thread was called (after begin cb) 
                by a gotothread ( or return from a child)  ( step.result is obj) with a previous step user answere put in step.state.userTurn
                OR
                by  begindialog with a previous step user answere put as string in step.result

                    - if this index 0 step has conditions to test 
                            >> we  can recover previous user answere put in step.state.userTurn ( and so set  recLTurn=true and GOON to test condition  ) 
                    -else we issue the step 0 msg in order to test condition with user answere to msg

*/

            if(!step.msgSent >-2)console.error(' RREEDD  just WARNING : RELAXED goon because step.msgSent, >-2 meand the previus message comes from the ask that goon to this th or a this th ask : \n step.msgSent=',step.msgSent,' >-2 condition allows to work with child obj return matching continue routing. '); 

                // last review 24052021
                console.log(' > Ending current Step at index ' + step.index ,' , after tested previous ask ',prevName,'with text result (that can be a answer coming from a step before) OR obj result (child,...) \n now applying  GOON directive:\n NEXT  condition will initially be match with a RESULT (if text is the user answer) not related to this step ( answer to templateprompt  but to a previous prompt',
                    '\n so in next step current RESULT (user answer to a template or OBJ injected by child/resume related to a index < ',step.index,' ) will be used to match the condition on ask in step ',step.index,' ;  THATS NOT user answer to its prompting but :\n -if the current step.RESULT is text (',step.msgSent>-777,') : we use that result  that is produced/injected/coming from index ',step.msgSent,' <  ',step.index,
                    '\n - if the current step.RESULT is obj (msgSent=-777, thats  (',step.msgSent==-777,')) : use the before user text answer state.userTurn ,from before step: ',step.state.goon,' , that should be used if not coming from a child, so the answer coming from index step.goon');
                      //console.log('  because we do not retrying because of A ,\n A means :we dont match the condition on a step of index ',step.index-1 , ' on  msg of index ',step.msgSent,' that was a msg of a step before \n');

                      if(step.index >0)console.log('  in a step >0  we  matched a non def  condition on a step of index ',step.index-1 , ' on  prompt of index ',step.msgSent,' that is a step before this step \n',
                         ' >> otherwise we retry/replay the step prompting its msg' );
                      else console.log('  in a step 0 we could recover a previous user msg (step ',step.msgSent,' <0)  answer and with this (goon ) answer we are going to test step 0 condition \n the user answer is :  ',step.result);


                        let result;
                        if (step.index >0&&step.result && typeof step.result !== 'string' && state.userTurn){
                            
                            
                            // ERROR ERROR ERROR:       step.state.goon=step.msgSent; 
                            //      the state.goon remain the same without change , because in the ask we returning from a child so we use the child result to test the condition, innext step we can use the current before text user answer that 
                            //      is still pending to test goon ask

                            result=state.userTurn;
                        }else {// if index=0 the result is text forwarded from before asks
                            step.state.goon=step.msgSent;  // okok:
                            // inform following calling runstep ( the (current) index in runstep is this index +1) that :
                            //  - the msg/prompt the user answered (msgSent=currrentindex-2)was not previous=current_index-1 but  a step before 
                            //  - so if the step dont match the previous must replay/retry
                            result=step.result;// 012021 : restore past text result in case of child return in meddle of a thread  
                        }
                    //return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.result);
                    if(curkey){// =line.collect,  avoid prompting but goon with passed text answer (index = step.state.goon)
                        // return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled,result);// 022021 chaino il successivo runStep senza ritornare il current (il bot non manda la risposta !)
 
                                        // 052021 >>>>>> here we normally dc.prompt() to prompt user with ask template to get user answer to apply to ask conditions starting a next step with dc.continue on next turn   
                                        // BUT some ask condition matched so now goon to next step with passed user answer without prompt user mantaining current passed result as answer
                                        //      calling directly runStep() with passed result (instead to call standard step.next())

                                        //     
                                        console.log(' goon aplying to a collecting ask so goto next step  whith current result');
                        return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled,result);// 022021 chaino il successivo runStep senza ritornare il current (il bot non manda la risposta !)
 
                    }else{// emit messages without prompting then  goon with passed text answer (index = step.state.goon)
                        console.log(' goon applying to a no collecting ask so emit message , no wait for aswer and goto next step  whith current result');
                        if (line.type || line.text || line.attachments || (line.channelData && Object.keys(line.channelData).length)) {
                            if(goOnWOColl2)runChannelDataScript(this,line); // apply script before copy line.channelData see PCCrunChannelDataScript(previous); // see PCC
                            yield dc.context.sendActivity(this.makeOutgoing(line, step.values,step,dc));
                        }
                        else if (!line.action) {
                            console.error('Dialog contains invalid message a ask with no template must have an action', line);
                        }
                        if (line.action) {
                            // if the action is different then next (begindialog/repeat/goto thread) next ask will goon recovering the passed answer using state 
                            console.error(' just CHECK : ending current handling with not prompting message,GOON  mode, found a line.action:',line.action);
                             let res = yield this.handleAction(line, dc, step);
                              if (res !== false) {  // >>>>>  handleaction routed so exit 
                                  return res; }
                          
                        }

                        // so we goto next , instead of :
                        // return yield step.next();// 022021 chaino il next step index+1 ma prima recupero lo stato con resume() . WHY need to pass to resume() ???? . senza chiudere il turno ??? !!!!!
                        // OR return yield step.next(result)

                        // apply goon  with passed user answer
                        //  >>>>> handleaction returned false , so  want to goto next so do here applying goon with current passed user answer/result
                        //   BUT CHECK THIS BEHAVIOUR :
                        console.error(' just CHECK : ending current handling with not prompting message,GOON  mode,  check that line.action should be continue/next, in effect it is:',line.action);
                        return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled,result);// 022021 chaino il successivo runStep senza ritornare il current (il bot non manda la risposta !)

                }
                // returned , exit !!!
                }  
                 else 
                 console.log(' > Ending current Step Handling WITHOUT GOON  support on passed answer , now prompt the ask msg of index ',step.index,':',
                 '\n - expone user answer to ask condition (dialog.continue() will call next step) PROMPTing msg of index  ',step.index,' ( past user answer allowed on index 0 ???)  askname: ',curkey,', goonDir2=',goonDir2,
                 '\n - apply line.action to route (if next we dont apply goon ( so dont pass current result to next step)  ), but call normal step.next()');
                 

                // APPLY STANDARD NOT GOON line routing

                // If a prompt is defined in the script, use dc.prompt to call it.
                // This prompt must be a valid dialog defined somewhere in your code!
                if (line.collect && line.action !== 'beginDialog') {// 022021  2 alternative sendactivity(just record/send part of message,waiting a prompt to send and then process user response/answer) o dc.prompt uno (dc.prompt) causa la fine del turno ??
                    try {
                        // seems will start a begindialog ( will issue a prompt) put on top of stake returning here after received the user answare
                        // so  returning from a begindialog will call dc.endDialog that come back here in resumedialog 
                        return yield dc.prompt(this._prompt, this.makeOutgoing(line, step.values,step,dc));// send the prompt to customer via a prompt dialog that will receive the user answer and the pas to this convo)
                    }
                    catch (err) {
                        console.error(err);
                        yield dc.context.sendActivity(`Failed to start prompt ${this._prompt}`);
                        return yield step.next();
                    }
                    // If there's nothing but text, send it!
                    // This could be extended to include cards and other activity attributes.
                }
                else {// send a first message but not collect/process x user answer, we'll send another message with  prompt so we'll process user answer
                    // if there is text, attachments, or any channel data fields at all...
                    if (line.type || line.text || line.attachments || (line.channelData && Object.keys(line.channelData).length)) {
                        yield dc.context.sendActivity(this.makeOutgoing(line, step.values,step,dc));
                    }
                    else if (!line.action) {
                        console.error('Dialog contains invalid message', line);
                    }
                    if (line.action) {
                        let res = yield this.handleAction(line, dc, step);
                        if (res !== false) {
                            return res;
                        }
                    }
                    /*
                    if(goOnWOColl2&&step.index < thread.length-1&&goonDir2&&step.msgSent>0&&step.index >0){
                        // 052021 : if step>0, and goon chain direcly also if there ane any collect in current step , (just set goon state correcly ???) 05/2021


                            let result;
                            if (step.index >0&&step.result && typeof step.result !== 'string' && state.userTurn){
                                
                                
                                // ERROR ERROR ERROR:       step.state.goon=step.msgSent; 
                                //      the state.goon remain the same without change , because in the ask we returning from a child so we use the child result to test the condition, innext step we can use the current before text user answer that 
                                //      is still pending to test goon ask
    
                                result=state.userTurn;
                            }else {
                                step.state.goon=step.msgSent;  // okok:
                                // inform following calling runstep ( the (current) index in runstep is this index +1) that :
                                //  - the msg/prompt the user answered (msgSent=currrentindex-2)was not previous=current_index-1 but  a step before 
                                //  - so if the step dont match the previous must replay/retry
                                result=step.result;// 012021 : restore past text result in case of child return in meddle of a thread  
                            }

                    //return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.result);
                    return yield this.runStep(dc, step.index+1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled,result);//
                    }else
                    */
                   console.error(' just  CHECK : ending current handling with not prompting message, NO GOON  mode,  check that line.action should be continue/next, in effect it is:',line.action);
                    return yield step.next();// 022021 chaino il next step index+1 ma prima recupero lo stato con resume() . WHY need to pass to resume() ???? . senza chiudere il turno ??? !!!!!
                }
            }
            else {
                // End of script so just return to parent
                return yield this.end(dc);
            }
        });
    }
    /**
     * Run a dialog step, based on the index and thread_name passed in.
     * @param dc The current DialogContext
     * @param index The index of the current step
     * @param thread_name The name of the current thread
     * @param reason The reason given for running this step
     * @param result The result of the previous turn if any : 
     *              >>>  a string or the values of the switching thread or returning child dialog step.values ( nb: are also in state)
     */
    runStep(dc, index, thread_name, reason, result) {// if coming from gotothread or child dialog, result  is a step.values obj
        return __awaiter(this, void 0, void 0, function* () {

            // Update the step index
            const state = dc.activeDialog.state;// the state of this convo
            state.stepIndex = index;
            state.thread = thread_name;
            // Create step context
            const nextCalled = false;// ?? 

// hotel customization 
            /* moved to conversation :
           //  when receiving text (user answere put in userTurn , that can be used in onStep usually at index 0 )
           // >>>>>  better set state.userTurn in caller  dc.xxxDialog()
           // if(Object.prototype.toString.call(myVar) === "[object String]")
            if(typeof result === 'string' || result instanceof String){
                state.userTurn=result;
            }else state.userTurn=null;
            */

            /* to move to conversation :
            let msgSent;// the
            // goon should warn that we goon to next step using a previous msg prompt , 
            // >>>>>>>>>>>>>>>>  so shoud be index-1 otherwise should be index -2 ??
            if(state.goon||state.goon>=index-1){msgSent=state.goon;// usually step run with a user answare to msg of step with index-1 
                console.log('\n runstep thread: ',thread_name,' index is ' + index ,' setgoon is set in TT when goon with no step msg : ',state.goon,' text is ',result);
            }else msgSent=state.goon;???????????
            state.goon=null;// ???
*/


            const step = {

                //msgSent,// here usually call index with user answere to previous msg 

                index: index,
                thread: thread_name,
                state: state,
                options: state.options,
                reason: reason,
                result: result,
                values: state.values,
                next: (stepResult) => __awaiter(this, void 0, void 0, function* () {
                    if (nextCalled) {
                        throw new Error(`ScriptedStepContext.next(): method already called for dialog and step '${this.id}[${index}]'.`);
                    }
                    return yield this.resumeDialog(dc, botbuilder_dialogs_1.DialogReason.nextCalled, stepResult);
                })
            };


            // already done : step.state.dir=step.state.dir||{}; >>>>>>  ERROR? coming from beginDialog state.dir is reset and diverge from father state.dir brought in session.dir
            // usually when comes here after a replay current replayed onstep will emitt he msg , 
            //  then the user will come back into the active convo (top stack) after a prompt dialog ends with a resume, that will call here
            if(state.dir.repeat&&state.dir.count){
                // a repeat is requested, now send msg, warn continue dialog to check the expecting flag state.dir.repeat_
                state.dir.count++;// seems to count also the first 
                state.dir.repeat_=1;
                state.dir.repeat=false;
            }
            else { if(state.dir.repeat_>1){// check that continuedialog did ++ ( he saw state.dir.repeat_>0)
                    // confirm count , then reset all flags 
                }else{// start counting
                    state.dir.count=1;
                }
                state.dir.repeat=false;//reset all
                state.dir.repeat_=0;
            }

            // display count ( -1 )
            state.dir.counter=state.dir.count-1;

            // did we just start a new thread?
            // if so, run the before stuff.
            if (index === 0) {
                console.log('\n ** start runStep , cmd ',dc.activeDialog.id,' , thread ',thread_name,', step ',index);
                // check if recover text from previous (loopDir.goon!=false)
                if(step.state.userTurn&&state.values.direc&&state.values.direc[thread_name]&&state.values.direc[thread_name].loopDir&&!state.values.direc[thread_name].loopDir.goon)
                    step.state.userTurn=null;// msg in step 0 will ever be prompted

                yield this.runBefore(step.thread, dc, step);/* >>>>> SESSION/APP/matches/askmatches reset/updates are done if the cmd is registered  for (auto)fwsupport in 
                                                            // >>>>>  TAKE CARE when starting a CHILD default thread 
                                                            // as described in beginDialog if we start a new child state was so initilized :
                                                                - attach options, init dir as this.dir , clone options to values
                                                            do a summary of how session,appwrap,matches is managed on runBefore() set by  fwbase (depend from (auto) registration of directives|)
                                                            ......................
                                                            */
                // here the voice convo state.values  ( botkit vars exposed to template system)
                //      has been added ( see fwbase.initCmd that sets onBefore that uses onChange.getappWrap to bind session and app)  :
                //          .session (app state)
                //          .appWrap
                //           now init .dir ( directive state ) too in :
                //          .dir ( bind directive status)
                if(state.values.session)state.values.session.dir=state.dir;// session.dir (if starting child session is recovered from father) is reset to current state.dir. ERROR: should but some error 
                // >>>>>> unless updated by before() ,  session and matches,askmatches,,, comes from the father  if starting a new child
                //                                      QUESTION : in cloning to vars deeper obj are cloned ??????  ex matches ????
                // did we just change threads? if so, restart
                if (index !== step.index || thread_name !== step.thread) {
                    return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                }
            }
            //now we have session bind for sure in values.session
            // Execute step
            if(state.values.session)state.values.session.dir=state.dir;//21112020 news : ever reset session.dir 
            let emb=null;
            if(result&&
                (typeof result === 'string' || result instanceof String)
                &&(emb=result.indexOf('%%embed_'))>=0
                
                ){// see master_df_builder... XXFGRY : insert qualsiasi embeded della forma %%embed_simplybook-sermovox;) in session 
                let embi,embf,embed,embedv;
                if(((embi=result.indexOf('-',emb+8))>emb+8)&&((embf=result.indexOf(';',embi+1))>embi+1)){
                    embed=result.substring(emb+8,embi);// qs_parucchieri
                    embedv=result.substring(embi+1,embf);// start_ctx=enloc&par2=pippo
                    if(embed.substr(0,2)=='qs'){// decode qs from %%embed_qs_parucchieri-start_ctx=enloc&par2=pippo;
                        embedv = querystring.parse(embedv);//  

                    }
                    state.values.session[embed]=embedv;
                }
                
            }
            // debug only just copy count on session 
            // state.values.session.dir=state.dir;
            const res = yield this.onStep(dc, step);
            return res;
        });
    }
    /**
     * Automatically called when the the dialog ends and causes any handlers bound using `after()` to fire. Do not call this directly!
     * @ignore
     * @param dc The current DialogContext
     * @param value The final value collected by the dialog.
     */
    end(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: may have to move these around
            // shallow copy todo: may need deep copy

            const result = Object.assign({}, dc.activeDialog.state.values);
            yield dc.endDialog(result);// father will collect its clone of child vars on next ask
            yield this.runAfter(dc, result);
            return botbuilder_dialogs_1.DialogTurnStatus.complete;
        });
    }
    /**
     * Translates a line from the dialog script into an Activity. Responsible for doing token replacement.
     * @param line a message template from the script
     * @param vars an object containing key/value pairs used to do token replacement on fields in the message template
     */
    makeOutgoing(line, vars,step,dc) {// vars=step.values
        let outgoing;
        if (line.quick_replies) {
            outgoing = botbuilder_1.MessageFactory.suggestedActions(line.quick_replies.map((reply) => { return { type: botbuilder_1.ActionTypes.PostBack, title: reply.title, text: reply.payload, displayText: reply.title, value: reply.payload }; }), line.text ? line.text[0] : '');
        }
        else {
            outgoing = botbuilder_1.MessageFactory.text(line.text ? line.text[Math.floor(Math.random() * line.text.length)] : '');
        }
        if (!outgoing.channelData) {
            outgoing.channelData = {};
        }
        // set the type
        if (line.type) {
            outgoing.type = line.type;
        }
        // copy all the values in channelData fields. we'll find channelData fields in returned message on adapter
        for (var key in line.channelData) {
            outgoing.channelData[key] = line.channelData[key];
        }
        // copy all the values in matched 
            let knam;
        if(line.collect&&line.collect.key){

            outgoing.channelData.thread = step.thread;
            outgoing.channelData.key = knam=line.collect.key;
            let outCtx;
            if(line.collect.options){
                outCtx=[];
                line.collect.options.forEach(function(v,i){
                    
                    if(v.pattern&&v.pattern.substring(0, 2) == '$$'&&v.action!='next') {
                        let ext=v.pattern.indexOf(":");
                        if(ext>0)outCtx.push(v.pattern.substring(2,ext)+"/"+v.action);
                    }
                    }
                    );
            if(outCtx.length>0)outgoing.channelData.outCtx = outCtx;
            }
        }
        if(vars.matches){
            let matches=[];
            for (var key in vars.matches) {
            if(vars.matches[key]&&vars.matches[key].match)matches.push(key+'='+vars.matches[key].match);
            }
        outgoing.channelData.matches = matches;
        }
        if(vars.askmatches){
            let askmatches=[];
           // console.log(' XXXXXX >>>>>>>>>>  testing in key nam ',knam, ' askmatches: ',vars.askmatches);
            for (var key in vars.askmatches) {
             //   console.log('       >>>>>>>>>>  test key on askmatches ',key, ' obj ',vars.askmatches[key]);
            if(vars.askmatches[key]&&vars.askmatches[key].match)askmatches.push(key);// also =matchval ?
            }
        outgoing.channelData.askmatches = askmatches;// shown as mathedStep
        }


        let rtext=outgoing.text;
        // Handle template token replacements
        if (outgoing.text) {

            // 'so you just said conf !,....' 
           // let context = { vars: vars, conf: step.values.__conf };// can be more articulated.do not pass appstatus , conf is the match the user did in last turn
            let context = { vars: vars, conf: step.values.__conf,channelData:outgoing.channelData };// 052021 can be more articulated.do not pass appstatus , conf is the match the user did in last turn


            // add step as closure var in out
            let must_inst = this.mustacheF,
                //let must_inst=this._controller.plugin.vCtl.mustacheF,
                outInst = must_inst.out__; ////////////////////////////////// error:because  must_inst is null 

            let casa = true;
            if (casa) {
                // substitute .out(): insert step in out param via a clusure var
                must_inst.out = (function () {                                
                    let myctx = step;

                    /*
                    //return function(text, render){ outInst.call(this,text,render,myctx)}
                    return function(){
                        console.log('mustache meet a function out and asked a handler');
    
    
                        return function(text, render){
                            console.log('mustache out  handle called for process inner  template : ',text);
                             outInst.call(this,text,render,myctx)}
                    }*/
                    console.log('mustache meet a function out and asked a handler');
                    return outInst(myctx,outgoing.channelData);

                })();

            } else this.mustacheF.out = this.mustacheF.out_;

            let asknam = 'NA'; if (line.collect && line.collect.key) asknam = line.collect.key;
            if (this.mustacheF) {
            context.mustacheF = this.mustacheF;// add function (not saved in state)
                // overwrite by mustache !!if(this.mustacheF.out&&step){this.mustacheF.out.bind(step);}
                // so just insert step into context !
                context.step = step;
                step.curLine = line;// pass into step the  ask name passing line . uso : ........

                // insert vars calc between &&....&&  example : template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated
                outgoing.text = looseJsonParse(outgoing.text, Object.assign({}, context.vars),null,null,null,null,outgoing.channelData);
                
                if (lv > 5) console.log(' outgoing is rendering msg of msgAsk ', asknam, ' context ', context);

            }
            outgoing.text = mustache.render(outgoing.text, context);//{ vars: vars });
            step.values.__conf = null;
           // console_.log(3, '\nconvId:' + dc.context.activity.conversation.id + '\n  convo.outgoing is rendering msg, msgAsk: ', asknam, ', text: ' + rtext + ' \n outgoing has rendered : ' + outgoing.text + ' context is ' + context);
 winston.info('\nconvId:' + dc.context.activity.conversation.id + '\n  convo.outgoing is rendering msg, msgAsk: '+ asknam+', text: ' + rtext + ' \n outgoing has rendered : ' + outgoing.text + ' context is ' + context,{pgm:'conversation'});        }
        // process templates in native botframework attachments
        if (line.attachments) {
            outgoing.attachments = this.parseTemplatesRecursive(line.attachments, vars);
        }
        // process templates in slack attachments
        if (outgoing.channelData.attachments) {
            outgoing.channelData.attachments = this.parseTemplatesRecursive(outgoing.channelData.attachments, vars);
        }
        // process templates in facebook attachments
        if (outgoing.channelData.attachment) {
            outgoing.channelData.attachment = this.parseTemplatesRecursive(outgoing.channelData.attachment, vars);
        }
        return outgoing;
    }
    /**
     * Responsible for doing token replacements recursively in attachments and other multi-field properties of the message.
     * @param attachments some object or array containing values for which token replacements should be made.
     * @param vars an object defining key/value pairs used for the token replacements
     */
    parseTemplatesRecursive(attachments, vars) {
        if (attachments && attachments.length) {
            for (let a = 0; a < attachments.length; a++) {
                for (let key in attachments[a]) {
                    if (typeof (attachments[a][key]) === 'string') {
                        attachments[a][key] = mustache.render(attachments[a][key], { vars: vars });
                    }
                    else {
                        attachments[a][key] = this.parseTemplatesRecursive(attachments[a][key], vars);
                    }
                }
            }
        }
        else {
            for (let x in attachments) {
                if (typeof (attachments[x]) === 'string') {
                    //let context={ vars: vars };// can be more articulated
                    //if(vars.excel.out)vars.excel.out.bound(step);
                    let context={ vars: vars };// can be more articulated
                    attachments[x] = mustache.render(attachments[x], context);
                }
                else {
                    attachments[x] = this.parseTemplatesRecursive(attachments[x], vars);
                }
            }
        }
        return attachments;
    }
    /**
     * Handle the scripted "gotothread" action - requires an additional call to runStep.
     * @param thread The name of the thread to jump to
     * @param dc The current DialogContext
     * @param step The current step object
     */
    gotoThreadAction(thread, dc, step) {
        return __awaiter(this, void 0, void 0, function* () {
            step.thread = thread;
            step.index = 0;
            return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
        });
    }
    /**
     * Accepts a Botkit script action, and performs that action
     * @param path A conditional path in the form {action: 'some action', handler?: some handler function, maybe_other_fields}
     * @param dc The current DialogContext
     * @param step The current stpe object
     */
    handleAction(path, dc, step) {
        // for path ( condition) format see addQuestion(message, handlers, key, thread_name)
        return __awaiter(this, void 0, void 0, function* () {
            if (path.handler) {//a ask handler set with addQuestion(message, handlers, key, thread_name) 
                const index = step.index;
                const thread_name = step.thread;
                // spawn a bot instance so devs can use API or other stuff as necessary
                const bot = yield this._controller.spawn(dc);
                // create a convo controller object
                const convo = new dialogWrapper_1.BotkitDialogWrapper(dc, step);
                yield path.handler.call(this, step.result, convo, bot);
                // did we just change threads? if so, restart this turn
                if (index !== step.index || thread_name !== step.thread) {
                    return yield this.runStep(dc, step.index, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled, step.values);
                }
                return false;
            }
            switch (path.action) {
                case 'next':
                    // noop
                    break;
                case 'complete':
                    step.values._status = 'completed';
                    return yield this.end(dc);
                case 'stop':
                    step.values._status = 'canceled';
                    return yield this.end(dc);
                case 'timeout':
                    step.values._status = 'timeout';
                    // what step.values._status = 'timeout' do ??????, 
                    //  seems  like the bot respond to a 'timeout' user msg goto to time_out thread !!!
                    //  probably if i have a one way channel it is convinient the client  to send at a time > time_out some void msg to the bot so can return bach the waiting time out prompt
                    //  how can return message on one way channel ???? try following this.end(dc)
                    return yield this.end(dc);
                case 'execute_script':
                    const ebot = yield this._controller.spawn(dc);
                    console.log(' handleAction : execute script was requested',path);
                    var clonop=Object.assign({ thread: path.execute.thread }, step.values);
                    //072019 anyway rewrite thread
                   clonop.thread=path.execute.thread;
                    return yield ebot.replaceDialog(path.execute.script, clonop);
                case 'beginDialog':
                console.log(' handleAction : begindialog was requested  ',path);
                    let rbot = yield this._controller.spawn(dc);
                    // pass a clone of father vars= step.values
                    let childOpt= Object.assign({ thread: path.execute.thread }, step.values);
                    // + a return model reference vars.matches[path.execute.script] with name = childname=path.execute.script as child return model
                    /*
                    if(step.values.matches)
                        if(step.values.matches[path.execute.script])childOpt[path.execute.script]=step.values.matches[path.execute.script];
                        else childOpt[path.execute.script]={};// overwrite the cloned ref
                        */
                    return yield rbot.beginDialog(path.execute.script, childOpt);// il child eredita tutte le vars del father ??? so i nuovi excel ??
                    // il option=step.values di questo father convo si trovano come option in begindialog del convo child ! see it 
                    case 'repeat':

                    step.state.dir.repeat=true;// luis flag to count repeat

                    return yield this.runStep(dc, step.index - 1, step.thread, botbuilder_dialogs_1.DialogReason.nextCalled);
                case 'wait':
                    // reset the state so we're still on this step.
                    step.state.stepIndex = step.index - 1;
                    // send a waiting status
                    return { status: botbuilder_dialogs_1.DialogTurnStatus.waiting };
                default:
                    // the default behavior for unknown action in botkit is to gotothread
                    if (this.script[path.action]) {
                        console.log(' handleAction : gotoThread was requested',path);
                        return yield this.gotoThreadAction(path.action, dc, step);
                    }
                    console.warn('NOT SURE WHAT TO DO WITH THIS!!', path);
                    break;
            }
            return false;
        });
    }
}// ends class BotkitConversation extends botbuilder_dialogs_1.Dialog 
exports.BotkitConversation = BotkitConversation;
//# sourceMappingURL=conversation.js.map

function indOf(key,matr,col){
    let ism=false,it;
    if(matr&&key)
for(it=0;it<matr.length;it++){
        if(matr[it][col]==key){ ism=true;break;}
    }
    if(ism)return it;else return -1;
}


function looseJsonParse(templ,vars,step,jsfunc,service,par,channelData){// todo check channelData when substitute &&....&& in template !
    
    //channelData is cf of ask. will be copyed to activity.channelData
    // RETURNS :
    //  - if templ :
    //       extract in TEMPL  string a vars . format  xxxx&&vars.excel.....&&yyyy
    //  - IF templ is null , evaluate fcfunc in scope of this function ( param vars and step are in scope !!)


    // see evalmozilla.js, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
    // call  ftempl=looseJsonParse(template,Object.assign({},context.vars,{aa}));
    // template= "some text{{&&let kk="5";vars["colore"];&&}}"// last js expression in &&....&& is calculated

        // usually used in case we want to generate same text (substituing the &&x&& x with the out calc) without use a onchange 
        // or also when in a msg we want to use a {{y}} a context var y ( calc as before)  depending from past status  
        // or 
        //  - in a condition we want to test not the user speech but the current vars values  
        //      in this case we can call :
        //          looseJsonParse(null,vars=Object.assign({},context.vars,{text}),conditionStringasFunctionjscode) 
        //          so in js code we can access  in js code to vars and also to user text as vars.text 

     let ioa,templP,fc,calc;
      if(!jsfunc&&templ){// // work on template nòly
        ioa = templ.indexOf('&&');
        templP=templ.split('&&');

      

       //      console.log('looseJsonParse : templP is :',templP);
     //if (ioa > 0){let ioa1 = templ.indexOf('&&',ioa+3);
      //  if(ioa1>0)fcorpus = templ.substring(ioa+2, ioa1);}

      // max 2 substitution 
      let ret;

      if(templP.length==3||templP.length==5||templP.length==7){// 1,2,max 3   && couples
      // evaluate fcorpus in context 
        fc=templP[1];// jsfunctionText
        console.log(' first looseJsonParse in template ...&&fc&&... evaluating fc js code , fc is :',fc);
        let myf='"use strict";' + fc;
        // calc=Function(myf)();
        //calc=Function('"use strict";' + fc)();
         //calc=Function( fc).call(vars);
        //calc=Function( fc).call(vars);
        calc=eval( fc);// eval has this scope to work with ! so also vars. eval() will return the last calculated expression 
        console.log('looseJsonParse in ...&&fc&&... evaluating fc:',fc,' evaluated : ',calc);
        // OK calc=eval(myf);
        //   console.log('looseJsonParse  calc :',calc);
        if(!(calc==null)&&!isNaN(calc))ret=templP[0].concat(calc).concat(templP[2]);else ret=templP[0].concat(templP[2]);
      }else {if(templP.length>0)console.log(' none or inchoerent && couple in msg template (to eval looseJsonParse in template ), so no substitution done in template');  return templ;}// without eval anything
      if(templP.length==5||templP.length==7){
        // evaluate fcorpus in context 
          fc=templP[3];
          
          let myf='"use strict";' + fc;
          // calc=Function(myf)();
          //calc=Function('"use strict";' + fc)();
           //calc=Function( fc).call(vars);
           console.log(' second looseJsonParse in template ...&&fc&&... evaluating fc js code , fc is :',fc);
          calc=eval( fc);// or (myf) ??
          console.log('looseJsonParse : fc:',fc,' evaluated : ',calc);
          // OK calc=eval(myf);
          //   console.log('looseJsonParse  calc :',calc);
          if(calc!=null)ret=ret.concat(calc).concat(templP[4]);else ret=ret.concat(templP[4]);
        }else return ret;
        if(templP.length==7){
            // evaluate fcorpus in context 
              fc=templP[5];
              
              let myf='"use strict";' + fc;
              // calc=Function(myf)();
              //calc=Function('"use strict";' + fc)();
               //calc=Function( fc).call(vars);
               console.log(' third looseJsonParse in template ...&&fc&&... evaluating fc js code , fc is :',fc);
              calc=eval( fc);// or (myf) ??
              console.log('looseJsonParse : fc:',fc,' evaluated : ',calc);
              // OK calc=eval(myf);
              //   console.log('looseJsonParse  calc :',calc);
              if(calc!=null)ret=ret.concat(calc).concat(templP[6]);else ret=ret.concat(templP[6]);
            }else {
             //   console.error(' too much  looseJsonParse in template , after third are not evaluated !');  
                                return ret;
            }

      if(ret){
          console.log(' && case transformer text is ret= ',ret);return ret;}else return templ;
                                          
     // return Function('"use strict";return (' + obj + ')')();
      }else{// jsfunc case , we dont need template, just eval jsfunc // if there is a jsfunc (or template is void) : calc jsfunction on current this extended with vars 
        fc=jsfunc;
       
        let myf='"use strict";' + fc;
        try{calc=eval( fc);// fc has in scope  vars, and vars.text , return the last expression evaluated ( interessa vedere se e' false o no )
        } catch (e) {
            if (e instanceof SyntaxError) {
                console.error(' looseJsonParse :  on thread/step: ',step.thread,step.index,' evaluating: ',fc,' ,match failed x SYNTAX ERROR: ',e.message);
                calc=null;
            }else console.error(' looseJsonParse : on thread/step: ',step.thread,step.index,'evaluating: ',fc,' , match failed x ERROR: ',e.message);
        }
        if(calc){
            console.log('looseJsonParse : evaluated a boolean fc condition function :',fc,' returns x match : ',calc);
            // return true;// or just return calc ??
            return calc;
        }
        //else 
        console.log('looseJsonParse : evaluated a boolean fc condition function :',fc,' returns x match : false');
        return false;

      }
    }
